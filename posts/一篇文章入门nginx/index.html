<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Cuctut&#39;s blog | 一篇文章入门 Nginx</title>
    <meta name="description" content=" ">
    <link rel="canonical" href="https://cuctut.github.io/posts/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A5%E9%97%A8nginx/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="一篇文章入门 Nginx" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cuctut.github.io/posts/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A5%E9%97%A8nginx/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-17T16:19:48+08:00" />
<meta property="article:modified_time" content="2023-08-17T16:19:48+08:00" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一篇文章入门 Nginx"/>
<meta name="twitter:description" content=""/>

    
        
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    
    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
        <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">Cuctut&#39;s blog</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/portfolio">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-spin fa-star'></i> 作品集</div>
                        </div>
                    </div>
                </a>
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/portfolio">
            <div class="burger-item">
                <i class='fa fa-spin fa-star'></i> 作品集
            </div>
        </a>
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">








    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/default/default3.jpg" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title">一篇文章入门 Nginx</div>
            <div class="hero-subtitle"></div>
            <div class="hero-date">
                    <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2023-8-17 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2023-8-17 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-folder"></i>
                        未收录
                        
                    </span>    
            </div>
            <div class="timelong">
                <span class="no-wrap"><i class="fa fa-pencil"></i> 文章字数: 6837 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-clock-o"></i> 阅读时间: 14 分钟 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-eye"></i> 阅读量: <span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="content-root">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="content">
            <div class="content-self">
                <h1 id="概述">概述</h1>
<p>在此之前我对 Nginx 的了解还只是会抄会用的地步，用它进行简单的路由和静态页面的发送，一些概念和思想没有深入的理解，现在写一篇总结加深学习。</p>
<h1 id="什么是-nginx">什么是 Nginx</h1>
<p>官方的回答是：</p>
<blockquote>
<p>nginx (pronounced &ldquo;engine x&rdquo;) is a free open source web server written by Igor Sysoev, a Russian software engineer. Since its public launch in 2004, nginx has focused on high performance, high concurrency and low memory usage. Additional features on top of the web server functionality, like load balancing, caching, access and bandwidth control, and the ability to integrate efficiently with a variety of applications, have helped to make nginx a good choice for modern website architectures. Currently nginx is the second most popular open source web server on the Internet.</p>
</blockquote>
<p>也就是说：Nginx 是一个 <strong>轻量级/高性能/反向代理</strong> 的 Web 服务器</p>
<p>其实回答的更多是为什么要用 Nginx，有什么好处？简单总结了以下几点：</p>
<ul>
<li>轻量：内存消耗小，开启 10 个 nginx 才占 150M 内存</li>
<li>高性能：可处理2-3万并发连接数，官方称能支持5万并发</li>
<li>反向代理：可以不暴露正式的服务器 IP 地址，安全，还实现了负载均衡</li>
<li>节省宽带：支持GZIP压缩，可以添加浏览器本地缓存</li>
<li>其他：跨平台、配置简单、稳定性高、高效处理静态文件、内置的健康检查功能&hellip;</li>
</ul>
<blockquote>
<p>关于跨平台：Windows 版本的 nginx 更像是一个概念验证，而不是一个功能齐全的移植。nginx 和 Windows 内核架构有一定的限制，目前不能很好地交互。已知的问题包括并发连接数量少得多，性能下降，没有缓存和带宽监管。</p>
</blockquote>
<p>众多特征中，其高性能和反向代理一直是 Nginx 的主要竞争点，特别是高性能，那么什么是反向代理？为什么要反向代理？为什么 Nginx 可以在轻量的同时实现高性能呢？</p>
<h2 id="nginx-反向代理负载均衡">Nginx 反向代理（负载均衡）</h2>
<p>首先复习下什么是反向代理？通俗的说，如果正向代理是用户端发送请求经过自己配置好的代理服务器到达指定的目标服务器，Nginx 反方代理则是请求统一被 Nginx 接收，由 Nginx 反向代理，<strong>非人为的</strong>、而是 Nginx 按照一定的规则分发给后端的业务处理服务器进行处理。</p>
<p>建议看完一篇更详细的文章：<a href="https://zhuanlan.zhihu.com/p/464965616">深入理解 http 反向代理（nginx）</a></p>
<p>这样做的最大的好处是可以隐藏源服务器的存在和特征。它充当互联网和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当使用 web 托管服务时。同时，由于可以反向代理，也就能实现负载均衡。推荐文章还提及可以进行协议的转换。</p>
<blockquote>
<p>tip
另外需要说的是, 一般提到反向代理, 通常是指 http 反向代理, 但反向代理的范围可以更大, 比如 tcp 反向代理, 在这里, 不打算讨论 tcp 之类的反向代理, 当文中说到反向代理时, 指的就是 http 反向代理。</p>
</blockquote>
<p>那么负载均衡有哪些策略？</p>
<h3 id="负载均衡策略">负载均衡策略</h3>
<ol>
<li>
<p>轮询(默认)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">upstream backserver <span class="o">{</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.12<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.13<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>权重 weight</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">upstream backserver <span class="o">{</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.12 <span class="nv">weight</span><span class="o">=</span>2<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.13 <span class="nv">weight</span><span class="o">=</span>3<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>ip_hash(IP绑定)</p>
<p>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的 <strong>session 共享问题</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">upstream backserver <span class="o">{</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.12<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.13<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>fair(第三方插件)</p>
<p>安装upstream_fair模块。对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">upstream backserver <span class="o">{</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.12<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server 192.168.0.13<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="nginx-高性能及其架构">Nginx 高性能（及其架构）</h2>
<p>讲高性能之前，我们先要了解 nginx 的高性能解决了什么问题？</p>
<h3 id="基于进程-vs-基于事件">基于进程 vs 基于事件</h3>
<p>传统上，<strong>基于进程或线程</strong> 的 web 服务器模型，在涉及处理并发连接时，常常使用单独的进程或线程处理每个连接，并阻塞网络或输入/输出操作。根据应用程序的不同，它在内存和CPU方面可能非常低效。生成一个单独的进程或线程需要准备一个新的运行时环境，包括分配堆和堆栈内存，以及创建一个新的执行上下文。创建这些项还需要花费额外的CPU时间，这可能最终导致性能下降，因为过多的上下文切换会导致线程抖动。</p>
<p>所有这些复杂性在 Apache 等较老的 web 服务器架构中表现出来。这是在提供一组丰富的通用特性和优化服务器资源使用之间的权衡。</p>
<p>所以从一开始，nginx 就打算成为一个专业的工具，在实现网站动态增长的同时，实现更高的性能、密度和更经济地使用服务器资源，所以它遵循了一个不同的模型。实际上，它的灵感来自于各种操作系统中正在进行的 <strong>基于事件</strong> 的高级机制的开发。</p>
<p>基于后者，最终形成的是一个 <strong>模块化的、事件驱动的、异步的、单线程的、非阻塞的</strong> 架构，它成为了 nginx 代码的基础。</p>
<p>因此，Nginx 大量使用 <strong>多路复用</strong> 和 <strong>事件通知</strong>，并将接收到的特定任务分配给单独的 <strong>进程</strong>。</p>
<p>在这些有限的<strong>单线程</strong>进程中，所有分配到手的特定任务都是在一个高效的运行循环中处理的。这就像分发任务给流水线的工人，所以这些单线程进程被称作 <code>workers</code>，每个 worker 每秒可以处理数千个并发连接和请求。</p>
<p><img src="/images/architecture.png" alt="architecture"></p>
<p>因为 nginx 不会为每个连接 fork 一个进程或线程，所以在大多数情况下，内存使用是非常保守和高效的。nginx 也节省了 CPU 周期，因为没有进程或线程的持续创建-销毁模式。nginx 所做的是检查网络和存储的状态，初始化新的连接，将它们添加到运行循环中，并<strong>异步处理</strong>直到完成，此时连接被释放并从运行循环中移除。结合对系统调用的谨慎使用和对pool 和 slab 内存分配器等支持接口的精确实现，nginx 即使在极端工作负载下也能实现中低的 CPU 使用率。</p>
<p>所以，什么是运行循环？如何实现了异步？要进一步理解 Nginx 高性能的实现，就有必要了解每一个 worker 是如何工作的。</p>
<h3 id="worker">Worker</h3>
<p>nginx worker 的代码包括核心和功能模块。</p>
<ul>
<li>
<p><strong>核心</strong> 是负责维护一个紧密的运行循环，并在请求处理的每个阶段执行模块代码的适当部分（其本质也是一个模块）。</p>
</li>
<li>
<p><strong>模块</strong> 拥有不同的化身，即核心模块、事件模块、阶段处理程序、协议、变量处理程序、过滤器、上游和负载平衡器。负责各种不同功能，如读取或写入网络和存储、转换内容、做出站过滤、操作请求并在代理被激活时将请求传递给上游服务器等。</p>
</li>
</ul>
<blockquote>
<p>tip
模块部分的梳理翻译可能词不达意，原文是：nginx modules come in slightly different incarnations, namely core modules, event modules, phase handlers, protocols, variable handlers, filters, upstreams and load balancers.</p>
</blockquote>
<p>核心运行高效率的循环，这个循环是 worker 代码中最复杂的部分，包含全面的内部调用，并很大程度上依赖于异步任务处理的思想，对应模块化的架构。<strong>关键原则是尽可能不阻塞</strong>（nginx 仍然可以阻塞的唯一情况是当工作进程没有足够的磁盘存储性能时）。</p>
<p>模块负责各自的工作，这种模块化架构通常允许开发人员在不修改 Nginx 核心的情况下扩展 web 服务器功能集。这种分工一方面提高了运行的效率，另一方面方便维护和扩展（目前还不支持动态加载模块）。</p>
<h3 id="io优化">I/O优化</h3>
<p>nginx 要处理各种操作，包括接收、处理和管理网络连接，或本地的内容检索，这对 I/O 性能有一定要求。在处理这些操作时，nginx 除了使用事件通知机制，还做了大量磁盘 I/O 性能增强（在 Linux、Solaris 和基于 BSD 的操作系统中），如<code>kqueue</code>，<code>epoll</code> 和 <code>event ports</code>。</p>
<p>针对每个基于 unix 的操作系统，nginx 使用不同的方法进行多路复用和高级I/O操作，进行了大量优化的，这也是说 nginx 高性能的重要原因。</p>
<h2 id="小总结">小总结</h2>
<p>nginx 在基于事件的高级机制下开发，避免多线程带来的缺点，以单线程的形式，结合模块化、异步处理的思想，尽可能减少阻塞，同时因为模块化、异步的特征，实现了反向代理、负载均衡等功能，再结合 I/O 优化，实现中低负载下的高并发。</p>
<h1 id="nginx-配置文件-nginxconf">Nginx 配置文件 nginx.conf</h1>
<p>在 Linux 下查看目录结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># tree /usr/local/nginx</span>
</span></span><span class="line"><span class="cl">/usr/local/nginx
</span></span><span class="line"><span class="cl">├── client_body_temp
</span></span><span class="line"><span class="cl">├── conf                <span class="c1"># Nginx所有配置文件的目录</span>
</span></span><span class="line"><span class="cl">│ ├── fastcgi.conf          <span class="c1"># fastcgi相关参数的配置文件</span>
</span></span><span class="line"><span class="cl">│ ├── fastcgi.conf.default  <span class="c1"># fastcgi.conf的原始备份文件</span>
</span></span><span class="line"><span class="cl">│ ├── fastcgi_params        <span class="c1"># fastcgi的参数文件</span>
</span></span><span class="line"><span class="cl">│ ├── fastcgi_params.default
</span></span><span class="line"><span class="cl">│ ├── koi-utf
</span></span><span class="line"><span class="cl">│ ├── koi-win
</span></span><span class="line"><span class="cl">│ ├── mime.types            <span class="c1"># 媒体类型</span>
</span></span><span class="line"><span class="cl">│ ├── mime.types.default
</span></span><span class="line"><span class="cl">│ ├── nginx.conf            <span class="c1"># Nginx主配置文件</span>
</span></span><span class="line"><span class="cl">│ ├── nginx.conf.default
</span></span><span class="line"><span class="cl">│ ├── scgi_params           <span class="c1"># scgi相关参数文件</span>
</span></span><span class="line"><span class="cl">│ ├── scgi_params.default
</span></span><span class="line"><span class="cl">│ ├── uwsgi_params          <span class="c1"># uwsgi相关参数文件</span>
</span></span><span class="line"><span class="cl">│ ├── uwsgi_params.default
</span></span><span class="line"><span class="cl">│ └── win-utf
</span></span><span class="line"><span class="cl">├── fastcgi_temp        <span class="c1"># fastcgi临时数据目录</span>
</span></span><span class="line"><span class="cl">├── html                <span class="c1"># Nginx默认站点目录</span>
</span></span><span class="line"><span class="cl">│ ├── 50x.html              <span class="c1"># 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面</span>
</span></span><span class="line"><span class="cl">│ └── index.html            <span class="c1"># 默认的首页文件</span>
</span></span><span class="line"><span class="cl">├── logs                <span class="c1"># Nginx日志目录</span>
</span></span><span class="line"><span class="cl">│ ├── access.log            <span class="c1"># 访问日志文件</span>
</span></span><span class="line"><span class="cl">│ ├── error.log             <span class="c1"># 错误日志文件</span>
</span></span><span class="line"><span class="cl">│ └── nginx.pid             <span class="c1"># pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件</span>
</span></span><span class="line"><span class="cl">├── proxy_temp          <span class="c1"># 临时目录</span>
</span></span><span class="line"><span class="cl">├── sbin                <span class="c1"># Nginx命令目录</span>
</span></span><span class="line"><span class="cl">│ └── nginx                 <span class="c1"># Nginx的启动命令</span>
</span></span><span class="line"><span class="cl">├── scgi_temp           <span class="c1"># 临时目录</span>
</span></span><span class="line"><span class="cl">└── uwsgi_temp          <span class="c1"># 临时目录</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以找到 nginx.conf，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">worker_processes 1；            <span class="c1"># worker进程的数量</span>
</span></span><span class="line"><span class="cl">events <span class="o">{</span>                        <span class="c1"># 事件区块</span>
</span></span><span class="line"><span class="cl">    worker_connections 1024；   <span class="c1"># 每个worker进程支持的最大连接数</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">http <span class="o">{</span>                          <span class="c1"># HTTP区块</span>
</span></span><span class="line"><span class="cl">    include mime.types；        <span class="c1"># Nginx支持的媒体类型库文件</span>
</span></span><span class="line"><span class="cl">    default_type application/octet-stream； <span class="c1"># 默认的媒体类型</span>
</span></span><span class="line"><span class="cl">    endfile on；                <span class="c1"># 开启高效传输模式</span>
</span></span><span class="line"><span class="cl">    keepalive_timeout 65；      <span class="c1"># 连接超时</span>
</span></span><span class="line"><span class="cl">    server <span class="o">{</span>                    <span class="c1"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span>
</span></span><span class="line"><span class="cl">        listen 80；             <span class="c1"># 提供服务的端口，默认80</span>
</span></span><span class="line"><span class="cl">        server_name localhost； <span class="c1"># 提供服务的域名主机名</span>
</span></span><span class="line"><span class="cl">        location / <span class="o">{</span>            <span class="c1"># 第一个location区块开始</span>
</span></span><span class="line"><span class="cl">            root html；         <span class="c1"># 站点的根目录，相当于Nginx的安装目录</span>
</span></span><span class="line"><span class="cl">            index index.html index.htm； <span class="c1"># 默认的首页文件，多个用空格分开</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        error_page <span class="m">500502503504</span> /50x.html； <span class="c1"># 出现对应的http状态码时，使用50x.html回应客户</span>
</span></span><span class="line"><span class="cl">        <span class="nv">location</span> <span class="o">=</span> /50x.html <span class="o">{</span>  <span class="c1"># location区块开始，访问50x.html</span>
</span></span><span class="line"><span class="cl">            root html；         <span class="c1"># 指定对应的站点目录为html</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">......
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="location">location</h2>
<p>location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作。</p>
<table>
<thead>
<tr>
<th>匹配符</th>
<th>匹配规则</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>精确匹配</td>
<td>1</td>
</tr>
<tr>
<td>^~</td>
<td>以某个字符串开头</td>
<td>2</td>
</tr>
<tr>
<td>~</td>
<td>区分大小写的正则匹配</td>
<td>3</td>
</tr>
<tr>
<td>~*</td>
<td>不区分大小写的正则匹配</td>
<td>4</td>
</tr>
<tr>
<td>!~</td>
<td>区分大小写不匹配的正则</td>
<td>5</td>
</tr>
<tr>
<td>!~*</td>
<td>不区分大小写不匹配的正则</td>
<td>6</td>
</tr>
<tr>
<td>/</td>
<td>通用匹配，任何请求都会匹配到</td>
<td>7</td>
</tr>
</tbody>
</table>
<h2 id="限流配置">限流配置</h2>
<p>Nginx 限流就是限制用户请求速度，防止服务器受不了，限流有3种：</p>
<ol>
<li>正常限制访问频率（正常流量）</li>
<li>突发限制访问频率（突发流量）</li>
<li>限制并发连接数</li>
</ol>
<p>Nginx 的限流都是基于漏桶流算法，之后会说什么是漏桶流算法。</p>
<h3 id="正常限制访问频率正常流量">正常限制访问频率（正常流量）</h3>
<p>限制一个用户发送的请求，Nginx 多久接收一个请求。
Nginx 中使用 <code>ngx_http_limit_req_module</code> 模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用 <code>limit_req_zone</code> 命令及 <code>limit_req</code> 命令限制单个IP 的请求处理频率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉，1r/s代表1秒一个请求，1r/m一分钟接收一个请求</span>
</span></span><span class="line"><span class="cl">limit_req_zone <span class="nv">$binary_remote_addr</span> <span class="nv">zone</span><span class="o">=</span>one:10m <span class="nv">rate</span><span class="o">=</span>1r/m<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#绑定限流维度</span>
</span></span><span class="line"><span class="cl">server<span class="o">{</span>
</span></span><span class="line"><span class="cl">    location/seckill.html<span class="o">{</span>
</span></span><span class="line"><span class="cl">        limit_req <span class="nv">zone</span><span class="o">=</span>zone<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_pass http://lj_seckill<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="突发限制访问频率突发流量">突发限制访问频率（突发流量）</h3>
<p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？</p>
<p>Nginx提供 <code>burst</code> 参数结合 <code>nodelay</code> 参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加 <code>burst</code> 参数以及 <code>nodelay</code> 参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉，1r/s代表1秒一个请求，1r/m一分钟接收一个请求</span>
</span></span><span class="line"><span class="cl">limit_req_zone <span class="nv">$binary_remote_addr</span> <span class="nv">zone</span><span class="o">=</span>one:10m <span class="nv">rate</span><span class="o">=</span>1r/m<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#绑定限流维度</span>
</span></span><span class="line"><span class="cl">server<span class="o">{</span>
</span></span><span class="line"><span class="cl">    location/seckill.html<span class="o">{</span>
</span></span><span class="line"><span class="cl">        limit_req <span class="nv">zone</span><span class="o">=</span>zone <span class="nv">burst</span><span class="o">=</span><span class="m">5</span> nodelay<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_pass http://lj_seckill<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>burst=5</code> 代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求。</p>
<h3 id="限制并发连接数">限制并发连接数</h3>
<p>Nginx中的 <code>ngx_http_limit_conn_module</code> 模块提供了限制并发连接数的功能，可以使用 <code>limit_conn_zone</code> 指令以及 <code>limit_conn</code> 执行进行配置。接下来我们可以通过一个简单的例子来看下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">http <span class="o">{</span>
</span></span><span class="line"><span class="cl">    limit_conn_zone <span class="nv">$binary_remote_addr</span> <span class="nv">zone</span><span class="o">=</span>myip:10m<span class="p">;</span>
</span></span><span class="line"><span class="cl">    limit_conn_zone <span class="nv">$server_name</span> <span class="nv">zone</span><span class="o">=</span>myServerName:10m<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">server <span class="o">{</span>
</span></span><span class="line"><span class="cl">    location / <span class="o">{</span>
</span></span><span class="line"><span class="cl">        limit_conn myip 10<span class="p">;</span>
</span></span><span class="line"><span class="cl">        limit_conn myServerName 100<span class="p">;</span>
</span></span><span class="line"><span class="cl">        rewrite / http://www.lijie.net permanent<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面配置了单个 IP 同时并发连接数最多只能 10 个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的 header 被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过 Nginx 是基于漏桶算法原理实现的，实际上限流一般都是<strong>基于漏桶算法</strong>和<strong>令牌桶算法</strong>实现的。接下来我们来看看两个算法的介绍。</p>
<h2 id="简述-漏桶算法和令牌桶算法">简述 漏桶算法和令牌桶算法</h2>
<h3 id="漏桶算法">漏桶算法</h3>
<p>漏桶算法是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。也就是我们刚才所讲的情况。</p>
<p>漏桶算法的机制如下：突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。</p>
<p><img src="/images/bucket.jpg" alt="bucket"></p>
<h3 id="令牌桶算法">令牌桶算法</h3>
<p>令牌桶算法是网络流量整形和速率限制中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。Google 开源项目 Guava 中的 RateLimiter 使用的就是令牌桶控制算法。</p>
<p>令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。</p>
<p><img src="/images/token.jpg" alt="token"></p>
<h1 id="用-nginx-解决前端跨域问题">用 nginx 解决前端跨域问题</h1>
<p>有两种方法解决跨域问题</p>
<h2 id="添加响应头解决跨域">添加响应头解决跨域</h2>
<p>-用GPT生成的文案-</p>
<p>在使用Nginx解决前端跨域问题时，你可以通过配置Nginx服务器来添加必要的HTTP响应头，以允许不同域之间的跨域请求。以下是一些步骤来实现这个目标：</p>
<ol>
<li>
<p>编辑 Nginx 配置文件</p>
<p>首先，需要编辑 Nginx 的配置文件。通常情况下，Nginx的配置文件位于 /etc/nginx/nginx.conf 或 /etc/nginx/conf.d/default.conf，具体位置取决于你的操作系统和Nginx的安装方式。</p>
<p>用你喜欢的文本编辑器打开配置文件。</p>
</li>
<li>
<p>添加跨域配置</p>
<p>在你的Nginx配置文件中，找到你想要解决跨域问题的服务器块（server 块），然后添加以下配置，以允许跨域请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">location / <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 允许所有域的跨域请求</span>
</span></span><span class="line"><span class="cl">    add_header <span class="s1">&#39;Access-Control-Allow-Origin&#39;</span> <span class="s1">&#39;*&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 允许指定的请求头</span>
</span></span><span class="line"><span class="cl">    add_header <span class="s1">&#39;Access-Control-Allow-Headers&#39;</span> <span class="s1">&#39;Authorization, Content-Type&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 允许指定的请求方法</span>
</span></span><span class="line"><span class="cl">    add_header <span class="s1">&#39;Access-Control-Allow-Methods&#39;</span> <span class="s1">&#39;GET, POST, OPTIONS&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 允许携带身份验证信息（例如Cookie）</span>
</span></span><span class="line"><span class="cl">    add_header <span class="s1">&#39;Access-Control-Allow-Credentials&#39;</span> <span class="s1">&#39;true&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 预检请求的有效期（OPTIONS请求的响应）</span>
</span></span><span class="line"><span class="cl">    add_header <span class="s1">&#39;Access-Control-Max-Age&#39;</span> 3600<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 是否允许将HTTP凭据（如Cookie和认证头）发送到服务器</span>
</span></span><span class="line"><span class="cl">    add_header <span class="s1">&#39;Access-Control-Allow-Headers&#39;</span> <span class="s1">&#39;Authorization,Content-Type,Accept,Origin,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Range,Range&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="nv">$request_method</span> <span class="o">=</span> <span class="s1">&#39;OPTIONS&#39;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 预检请求的响应</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Content-Length&#39;</span> 0<span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Allow-Origin&#39;</span> <span class="s1">&#39;*&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Allow-Headers&#39;</span> <span class="s1">&#39;Authorization, Content-Type&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Allow-Methods&#39;</span> <span class="s1">&#39;GET, POST, OPTIONS&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Allow-Credentials&#39;</span> <span class="s1">&#39;true&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Access-Control-Max-Age&#39;</span> 3600<span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Content-Type&#39;</span> <span class="s1">&#39;text/plain charset=UTF-8&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        add_header <span class="s1">&#39;Content-Length&#39;</span> 0<span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> 204<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，上述配置将允许所有域的跨域请求，但你可以根据需要进行自定义，例如将 &lsquo;Access-Control-Allow-Origin&rsquo; 的值更改为特定的域名。</p>
</li>
<li>
<p>重启 Nginx 服务</p>
<p>保存你的Nginx配置文件后，重启Nginx服务器，以使配置生效。你可以使用以下命令来重启Nginx，具体命令可能因你的操作系统而有所不同：</p>
</li>
</ol>
<p>sudo service nginx restart</p>
<blockquote>
<p>tip
请注意，配置Nginx解决跨域问题是一种常见的方法，但在实际应用中，你可能需要根据情况进行进一步的调整和配置，以确保安全性和正确性。同时，也可以考虑使用其他跨域解决方案，如JSONP、CORS（跨源资源共享）等，具体取决于你的需求和项目架构。</p>
</blockquote>
<h2 id="nginx-转发请求解决跨域">Nginx 转发请求解决跨域</h2>
<p>当使用Nginx作为代理服务器来解决前端跨域问题时，你可以通过将跨域的请求转发到同一域内的接口来绕过浏览器的跨域限制。这个方法的核心思想是，前端发起的跨域请求实际上是发送到同一域内的Nginx服务器，然后Nginx服务器将请求转发到真正的目标服务器，再将目标服务器的响应返回给前端，从而绕过浏览器的跨域限制。</p>
<p>下面是一个简单的示例来解释这个方法：</p>
<p>假设你有一个前端应用部署在域名 <code>https://frontend.com</code>，而你的后端服务部署在域名 <code>https://backend.com</code>。你希望前端能够访问后端的接口，但是由于跨域限制，直接从前端向后端发起请求会被阻止。</p>
<ol>
<li>
<p>配置 Nginx 作为代理
在Nginx的配置中，你可以配置一个代理服务器块，将前端的跨域请求转发到后端服务器。以下是一个简化的Nginx配置示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="cl"><span class="k">server</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kn">server_name</span> <span class="s">frontend.com</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kn">location</span> <span class="s">/api/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kn">proxy_pass</span> <span class="s">https://backend.com/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># ... 其他配置 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个配置中，当前端应用发送请求到 <code>/api/*</code> 路径时，Nginx会将请求转发到 <code>https://backend.com/*</code>。通过这种方式，前端实际上是与同一域内的 Nginx 服务器通信，从而绕过了浏览器的跨域限制。</p>
</li>
<li>
<p>前端调用代理接口</p>
<p>在前端应用中，你只需要将跨域的请求路径调整为 Nginx 代理的路径。例如，如果原本请求后端的路径是 <code>https://backend.com/api/data</code>，现在你可以调用 <code>https://frontend.com/api/data</code>，因为Nginx会将这个请求转发到后端。</p>
<p>通过这种方法，前端实际上是通过与同一域内的Nginx服务器通信，来访问后端的接口，从而避免了浏览器的跨域限制。</p>
</li>
</ol>
<p>选择哪种方法取决于你的项目需求和架构。如果你只需要解决基本的跨域问题，且后端支持CORS，那么使用响应头方式可能更为简单。如果你需要更灵活的控制，或者面对复杂的跨域情况，Nginx转发请求可能是一个更好的选择。</p>
<h1 id="关于-最大连接数">关于 最大连接数</h1>
<p>Nginx 作为通用服务器时，最大连接数：Worker 进程数量 x 单个 Worker 进程的最大连接数。</p>
<p>Nginx 作为反向代理服务器时，最大连接数：（Worker 进程数量 x 单个 Worker 进程的最大连接数）/ 2。</p>
<blockquote>
<p>tip
Nginx 反向代理时，会建立 Client 的连接和后端 Web Server 的连接，占用 2 个连接，对于 Client 来说，连接数减半。</p>
</blockquote>
<h1 id="关于-reload">关于 reload</h1>
<p>根据 nginx 的进程模型：一个master和多个worker进程，当 nginx 在接收到 <code>reload</code> 指令时，并不会马上停止所有的 worker，而是 master 重新加载配置文件后启动新的 worker，并告诉老的 worker 可以结束，从而达到不停机的效果。</p>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://aosabook.org/en/v2/nginx.html">The Architecture of Open Source Applications (Volume 2) nginx</a></p>
<p><a href="https://www.zhihu.com/question/20441060/answer/2528451837">nginx为什么性能这么优越？</a></p>
            </div>
            
                <div class="tags">
                    
                </div>
            
        </div>
        
            
                <div class="pre-next">
                    
    
        
        <a href="https://cuctut.github.io/posts/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98&#43;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="pre pre-last" style="text-align: center;">
            <span class="pre-icon"><i class="fa fa-hand-o-left"></i></span>
            <div class="pre-title-root">
                <span>Redis缓存击穿问题&#43;解决方案</span>
            </div>
        </a>
        
    
    

                </div>
            
        
    
</div>

    
        <div class="content-last">
            
                <button class="aixin content-last-item efct-button">
                    <i class="fa fa-heart"></i>
                </button>
            
            
        </div>
    


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">Cuctut</div>
            <div class="jianjie">
                Be the change.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>15</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>4</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>3</p>
        </a>
    </div>

    <a href="https://github.com/Cuctut">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/Cuctut" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://space.bilibili.com/172938182" class="link-item is-hidden-desktop" title="BiliBili">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            



    
    


<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">相关文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://cuctut.github.io/posts/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98&#43;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
                
<a href="https://cuctut.github.io/posts/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98&#43;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default/default3.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Redis缓存击穿问题&#43;解决方案
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-8-16</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">
                
<a href="https://cuctut.github.io/posts/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default/default3.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Redis的过期策略以及内存淘汰机制
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-8-14</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E5%86%85%E5%AD%98&#43;%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E4%B8%8D%E5%A4%9F/">
                
<a href="https://cuctut.github.io/posts/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E5%86%85%E5%AD%98&#43;%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E4%B8%8D%E5%A4%9F/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default/default3.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Redis为什么快？内存&#43;多线程还不够！
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-8-13</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/nacos%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/">
                
<a href="https://cuctut.github.io/posts/nacos%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default/default3.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Nacos配置热更新原理
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-6-11</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/sql%E8%AF%AD%E6%B3%95/">
                
<a href="https://cuctut.github.io/posts/sql%E8%AF%AD%E6%B3%95/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://images.unsplash.com/photo-1543722615-dbf5edf1a00d?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1476&amp;q=80 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                SQL语法
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-5-25</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>

    

<div class="sponsor">
    <div class="sponsor-self">
        <div class="sponsor-title">赞赏</div>
        <div class="sponsor-btn">
            
                
                    
                        <div class="sponsor-btn-1 border-r">Wechat</div>
                    
                
                
            
                
                    
                        <div class="sponsor-btn-2 border-l">Alipay</div>
                    
                
                
            
        </div>
        
        <div class="sponsor-img">
            
                
                    <img class="sponsor-img-1" src="/images/sponsor/wechat.jpeg" alt="">
                
                
            
                
                    <img class="sponsor-img-2" src="/images/sponsor/alipay.jpeg" alt="" style="display: none;">
                
                
            
        </div>
        <div class="cancel efct-button">取消</div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/Cuctut">Cuctut</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
        
    <div>
        <meting-js
            server = "netease"
            type = "playlist"
            id = "482655706"
            fixed = "true"
            autoplay = "false"
            loop = "all"
            order = "list"
            preload = "auto"
            list-folded = ""
            list-max-height = "250px"
            lrc-type = "1">
        </meting-js>
    </div>

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  15 ;
    var arrPosts = [{"link":"https://cuctut.github.io/posts/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A5%E9%97%A8nginx/","plain":"概述 在此之前我对 Nginx 的了解还只是会抄会用的地步，用它进行简单的路由和静态页面的发送，一些概念和思想没有深入的理解，现在写一篇总结加深学习。\n什么是 Nginx 官方的回答是：\nnginx (pronounced \u0026ldquo;engine x\u0026rdquo;) is a free open source web server written by Igor Sysoev, a Russian software engineer. Since its public launch in 2004, nginx has focused on high performance, high concurrency and low memory usage. Additional features on top of the web server functionality, like load balancing, caching, access and bandwidth control, and the ability to integrate efficiently with a variety of applications, have helped to make nginx a good choice for modern website architectures. Currently nginx is the second most popular open source web server on the Internet.\n也就是说：Nginx 是一个 轻量级/高性能/反向代理 的 Web 服务器\n其实回答的更多是为什么要用 Nginx，有什么好处？简单总结了以下几点：\n轻量：内存消耗小，开启 10 个 nginx 才占 150M 内存 高性能：可处理2-3万并发连接数，官方称能支持5万并发 反向代理：可以不暴露正式的服务器 IP 地址，安全，还实现了负载均衡 节省宽带：支持GZIP压缩，可以添加浏览器本地缓存 其他：跨平台、配置简单、稳定性高、高效处理静态文件、内置的健康检查功能\u0026hellip; 关于跨平台：Windows 版本的 nginx 更像是一个概念验证，而不是一个功能齐全的移植。nginx 和 Windows 内核架构有一定的限制，目前不能很好地交互。已知的问题包括并发连接数量少得多，性能下降，没有缓存和带宽监管。\n众多特征中，其高性能和反向代理一直是 Nginx 的主要竞争点，特别是高性能，那么什么是反向代理？为什么要反向代理？为什么 Nginx 可以在轻量的同时实现高性能呢？\nNginx 反向代理（负载均衡） 首先复习下什么是反向代理？通俗的说，如果正向代理是用户端发送请求经过自己配置好的代理服务器到达指定的目标服务器，Nginx 反方代理则是请求统一被 Nginx 接收，由 Nginx 反向代理，非人为的、而是 Nginx 按照一定的规则分发给后端的业务处理服务器进行处理。\n建议看完一篇更详细的文章：深入理解 http 反向代理（nginx）\n这样做的最大的好处是可以隐藏源服务器的存在和特征。它充当互联网和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当使用 web 托管服务时。同时，由于可以反向代理，也就能实现负载均衡。推荐文章还提及可以进行协议的转换。\ntip 另外需要说的是, 一般提到反向代理, 通常是指 http 反向代理, 但反向代理的范围可以更大, 比如 tcp 反向代理, 在这里, 不打算讨论 tcp 之类的反向代理, 当文中说到反向代理时, 指的就是 http 反向代理。\n那么负载均衡有哪些策略？\n负载均衡策略 轮询(默认)\n1 2 3 4 upstream backserver { server 192.168.0.12; server 192.168.0.13; } 权重 weight\n1 2 3 4 upstream backserver { server 192.168.0.12 weight=2; server 192.168.0.13 weight=3; } ip_hash(IP绑定)\n每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的 session 共享问题\n1 2 3 4 upstream backserver { server 192.168.0.12; server 192.168.0.13; } fair(第三方插件)\n安装upstream_fair模块。对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。\n1 2 3 4 upstream backserver { server 192.168.0.12; server 192.168.0.13; } Nginx 高性能（及其架构） 讲高性能之前，我们先要了解 nginx 的高性能解决了什么问题？\n基于进程 vs 基于事件 传统上，基于进程或线程 的 web 服务器模型，在涉及处理并发连接时，常常使用单独的进程或线程处理每个连接，并阻塞网络或输入/输出操作。根据应用程序的不同，它在内存和CPU方面可能非常低效。生成一个单独的进程或线程需要准备一个新的运行时环境，包括分配堆和堆栈内存，以及创建一个新的执行上下文。创建这些项还需要花费额外的CPU时间，这可能最终导致性能下降，因为过多的上下文切换会导致线程抖动。\n所有这些复杂性在 Apache 等较老的 web 服务器架构中表现出来。这是在提供一组丰富的通用特性和优化服务器资源使用之间的权衡。\n所以从一开始，nginx 就打算成为一个专业的工具，在实现网站动态增长的同时，实现更高的性能、密度和更经济地使用服务器资源，所以它遵循了一个不同的模型。实际上，它的灵感来自于各种操作系统中正在进行的 基于事件 的高级机制的开发。\n基于后者，最终形成的是一个 模块化的、事件驱动的、异步的、单线程的、非阻塞的 架构，它成为了 nginx 代码的基础。\n因此，Nginx 大量使用 多路复用 和 事件通知，并将接收到的特定任务分配给单独的 进程。\n在这些有限的单线程进程中，所有分配到手的特定任务都是在一个高效的运行循环中处理的。这就像分发任务给流水线的工人，所以这些单线程进程被称作 workers，每个 worker 每秒可以处理数千个并发连接和请求。\n因为 nginx 不会为每个连接 fork 一个进程或线程，所以在大多数情况下，内存使用是非常保守和高效的。nginx 也节省了 CPU 周期，因为没有进程或线程的持续创建-销毁模式。nginx 所做的是检查网络和存储的状态，初始化新的连接，将它们添加到运行循环中，并异步处理直到完成，此时连接被释放并从运行循环中移除。结合对系统调用的谨慎使用和对pool 和 slab 内存分配器等支持接口的精确实现，nginx 即使在极端工作负载下也能实现中低的 CPU 使用率。\n所以，什么是运行循环？如何实现了异步？要进一步理解 Nginx 高性能的实现，就有必要了解每一个 worker 是如何工作的。\nWorker nginx worker 的代码包括核心和功能模块。\n核心 是负责维护一个紧密的运行循环，并在请求处理的每个阶段执行模块代码的适当部分（其本质也是一个模块）。\n模块 拥有不同的化身，即核心模块、事件模块、阶段处理程序、协议、变量处理程序、过滤器、上游和负载平衡器。负责各种不同功能，如读取或写入网络和存储、转换内容、做出站过滤、操作请求并在代理被激活时将请求传递给上游服务器等。\ntip 模块部分的梳理翻译可能词不达意，原文是：nginx modules come in slightly different incarnations, namely core modules, event modules, phase handlers, protocols, variable handlers, filters, upstreams and load balancers.\n核心运行高效率的循环，这个循环是 worker 代码中最复杂的部分，包含全面的内部调用，并很大程度上依赖于异步任务处理的思想，对应模块化的架构。关键原则是尽可能不阻塞（nginx 仍然可以阻塞的唯一情况是当工作进程没有足够的磁盘存储性能时）。\n模块负责各自的工作，这种模块化架构通常允许开发人员在不修改 Nginx 核心的情况下扩展 web 服务器功能集。这种分工一方面提高了运行的效率，另一方面方便维护和扩展（目前还不支持动态加载模块）。\nI/O优化 nginx 要处理各种操作，包括接收、处理和管理网络连接，或本地的内容检索，这对 I/O 性能有一定要求。在处理这些操作时，nginx 除了使用事件通知机制，还做了大量磁盘 I/O 性能增强（在 Linux、Solaris 和基于 BSD 的操作系统中），如kqueue，epoll 和 event ports。\n针对每个基于 unix 的操作系统，nginx 使用不同的方法进行多路复用和高级I/O操作，进行了大量优化的，这也是说 nginx 高性能的重要原因。\n小总结 nginx 在基于事件的高级机制下开发，避免多线程带来的缺点，以单线程的形式，结合模块化、异步处理的思想，尽可能减少阻塞，同时因为模块化、异步的特征，实现了反向代理、负载均衡等功能，再结合 I/O 优化，实现中低负载下的高并发。\nNginx 配置文件 nginx.conf 在 Linux 下查看目录结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [root@localhost ~]# tree /usr/local/nginx /usr/local/nginx ├── client_body_temp ├── conf # Nginx所有配置文件的目录 │ ├── fastcgi.conf # fastcgi相关参数的配置文件 │ ├── fastcgi.conf.default # fastcgi.conf的原始备份文件 │ ├── fastcgi_params # fastcgi的参数文件 │ ├── fastcgi_params.default │ ├── koi-utf │ ├── koi-win │ ├── mime.types # 媒体类型 │ ├── mime.types.default │ ├── nginx.conf # Nginx主配置文件 │ ├── nginx.conf.default │ ├── scgi_params # scgi相关参数文件 │ ├── scgi_params.default │ ├── uwsgi_params # uwsgi相关参数文件 │ ├── uwsgi_params.default │ └── win-utf ├── fastcgi_temp # fastcgi临时数据目录 ├── html # Nginx默认站点目录 │ ├── 50x.html # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面 │ └── index.html # 默认的首页文件 ├── logs # Nginx日志目录 │ ├── access.log # 访问日志文件 │ ├── error.log # 错误日志文件 │ └── nginx.pid # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件 ├── proxy_temp # 临时目录 ├── sbin # Nginx命令目录 │ └── nginx # Nginx的启动命令 ├── scgi_temp # 临时目录 └── uwsgi_temp # 临时目录 可以找到 nginx.conf，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 worker_processes 1； # worker进程的数量 events { # 事件区块 worker_connections 1024； # 每个worker进程支持的最大连接数 } http { # HTTP区块 include mime.types； # Nginx支持的媒体类型库文件 default_type application/octet-stream； # 默认的媒体类型 endfile on； # 开启高效传输模式 keepalive_timeout 65； # 连接超时 server { # 第一个Server区块开始，表示一个独立的虚拟主机站点 listen 80； # 提供服务的端口，默认80 server_name localhost； # 提供服务的域名主机名 location / { # 第一个location区块开始 root html； # 站点的根目录，相当于Nginx的安装目录 index index.html index.htm； # 默认的首页文件，多个用空格分开 } error_page 500502503504 /50x.html； # 出现对应的http状态码时，使用50x.html回应客户 location = /50x.html { # location区块开始，访问50x.html root html； # 指定对应的站点目录为html } } } ...... location location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作。\n匹配符 匹配规则 优先级 = 精确匹配 1 ^~ 以某个字符串开头 2 ~ 区分大小写的正则匹配 3 ~* 不区分大小写的正则匹配 4 !~ 区分大小写不匹配的正则 5 !~* 不区分大小写不匹配的正则 6 / 通用匹配，任何请求都会匹配到 7 限流配置 Nginx 限流就是限制用户请求速度，防止服务器受不了，限流有3种：\n正常限制访问频率（正常流量） 突发限制访问频率（突发流量） 限制并发连接数 Nginx 的限流都是基于漏桶流算法，之后会说什么是漏桶流算法。\n正常限制访问频率（正常流量） 限制一个用户发送的请求，Nginx 多久接收一个请求。 Nginx 中使用 ngx_http_limit_req_module 模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用 limit_req_zone 命令及 limit_req 命令限制单个IP 的请求处理频率。\n1 2 3 4 5 6 7 8 9 #定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉，1r/s代表1秒一个请求，1r/m一分钟接收一个请求 limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m; #绑定限流维度 server{ location/seckill.html{ limit_req zone=zone; proxy_pass http://lj_seckill; } } 突发限制访问频率（突发流量） 上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？\nNginx提供 burst 参数结合 nodelay 参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加 burst 参数以及 nodelay 参数：\n1 2 3 4 5 6 7 8 9 #定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉，1r/s代表1秒一个请求，1r/m一分钟接收一个请求 limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m; #绑定限流维度 server{ location/seckill.html{ limit_req zone=zone burst=5 nodelay; proxy_pass http://lj_seckill; } } burst=5 代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求。\n限制并发连接数 Nginx中的 ngx_http_limit_conn_module 模块提供了限制并发连接数的功能，可以使用 limit_conn_zone 指令以及 limit_conn 执行进行配置。接下来我们可以通过一个简单的例子来看下：\n1 2 3 4 5 6 7 8 9 10 11 http { limit_conn_zone $binary_remote_addr zone=myip:10m; limit_conn_zone $server_name zone=myServerName:10m; } server { location / { limit_conn myip 10; limit_conn myServerName 100; rewrite / http://www.lijie.net permanent; } } 上面配置了单个 IP 同时并发连接数最多只能 10 个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的 header 被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过 Nginx 是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。接下来我们来看看两个算法的介绍。\n简述 漏桶算法和令牌桶算法 漏桶算法 漏桶算法是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。也就是我们刚才所讲的情况。\n漏桶算法的机制如下：突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。\n令牌桶算法 令牌桶算法是网络流量整形和速率限制中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。Google 开源项目 Guava 中的 RateLimiter 使用的就是令牌桶控制算法。\n令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。\n用 nginx 解决前端跨域问题 有两种方法解决跨域问题\n添加响应头解决跨域 -用GPT生成的文案-\n在使用Nginx解决前端跨域问题时，你可以通过配置Nginx服务器来添加必要的HTTP响应头，以允许不同域之间的跨域请求。以下是一些步骤来实现这个目标：\n编辑 Nginx 配置文件\n首先，需要编辑 Nginx 的配置文件。通常情况下，Nginx的配置文件位于 /etc/nginx/nginx.conf 或 /etc/nginx/conf.d/default.conf，具体位置取决于你的操作系统和Nginx的安装方式。\n用你喜欢的文本编辑器打开配置文件。\n添加跨域配置\n在你的Nginx配置文件中，找到你想要解决跨域问题的服务器块（server 块），然后添加以下配置，以允许跨域请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 location / { # 允许所有域的跨域请求 add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; # 允许指定的请求头 add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Authorization, Content-Type\u0026#39;; # 允许指定的请求方法 add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, OPTIONS\u0026#39;; # 允许携带身份验证信息（例如Cookie） add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; # 预检请求的有效期（OPTIONS请求的响应） add_header \u0026#39;Access-Control-Max-Age\u0026#39; 3600; # 是否允许将HTTP凭据（如Cookie和认证头）发送到服务器 add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Authorization,Content-Type,Accept,Origin,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Range,Range\u0026#39;; if ($request_method = \u0026#39;OPTIONS\u0026#39;) { # 预检请求的响应 add_header \u0026#39;Content-Length\u0026#39; 0; add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Authorization, Content-Type\u0026#39;; add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, OPTIONS\u0026#39;; add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; add_header \u0026#39;Access-Control-Max-Age\u0026#39; 3600; add_header \u0026#39;Content-Type\u0026#39; \u0026#39;text/plain charset=UTF-8\u0026#39;; add_header \u0026#39;Content-Length\u0026#39; 0; return 204; } } 请注意，上述配置将允许所有域的跨域请求，但你可以根据需要进行自定义，例如将 \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; 的值更改为特定的域名。\n重启 Nginx 服务\n保存你的Nginx配置文件后，重启Nginx服务器，以使配置生效。你可以使用以下命令来重启Nginx，具体命令可能因你的操作系统而有所不同：\nsudo service nginx restart\ntip 请注意，配置Nginx解决跨域问题是一种常见的方法，但在实际应用中，你可能需要根据情况进行进一步的调整和配置，以确保安全性和正确性。同时，也可以考虑使用其他跨域解决方案，如JSONP、CORS（跨源资源共享）等，具体取决于你的需求和项目架构。\nNginx 转发请求解决跨域 当使用Nginx作为代理服务器来解决前端跨域问题时，你可以通过将跨域的请求转发到同一域内的接口来绕过浏览器的跨域限制。这个方法的核心思想是，前端发起的跨域请求实际上是发送到同一域内的Nginx服务器，然后Nginx服务器将请求转发到真正的目标服务器，再将目标服务器的响应返回给前端，从而绕过浏览器的跨域限制。\n下面是一个简单的示例来解释这个方法：\n假设你有一个前端应用部署在域名 https://frontend.com，而你的后端服务部署在域名 https://backend.com。你希望前端能够访问后端的接口，但是由于跨域限制，直接从前端向后端发起请求会被阻止。\n配置 Nginx 作为代理 在Nginx的配置中，你可以配置一个代理服务器块，将前端的跨域请求转发到后端服务器。以下是一个简化的Nginx配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 server { listen 80; server_name frontend.com; location /api/ { proxy_pass https://backend.com/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # ... 其他配置 ... } 在这个配置中，当前端应用发送请求到 /api/* 路径时，Nginx会将请求转发到 https://backend.com/*。通过这种方式，前端实际上是与同一域内的 Nginx 服务器通信，从而绕过了浏览器的跨域限制。\n前端调用代理接口\n在前端应用中，你只需要将跨域的请求路径调整为 Nginx 代理的路径。例如，如果原本请求后端的路径是 https://backend.com/api/data，现在你可以调用 https://frontend.com/api/data，因为Nginx会将这个请求转发到后端。\n通过这种方法，前端实际上是通过与同一域内的Nginx服务器通信，来访问后端的接口，从而避免了浏览器的跨域限制。\n选择哪种方法取决于你的项目需求和架构。如果你只需要解决基本的跨域问题，且后端支持CORS，那么使用响应头方式可能更为简单。如果你需要更灵活的控制，或者面对复杂的跨域情况，Nginx转发请求可能是一个更好的选择。\n关于 最大连接数 Nginx 作为通用服务器时，最大连接数：Worker 进程数量 x 单个 Worker 进程的最大连接数。\nNginx 作为反向代理服务器时，最大连接数：（Worker 进程数量 x 单个 Worker 进程的最大连接数）/ 2。\ntip Nginx 反向代理时，会建立 Client 的连接和后端 Web Server 的连接，占用 2 个连接，对于 Client 来说，连接数减半。\n关于 reload 根据 nginx 的进程模型：一个master和多个worker进程，当 nginx 在接收到 reload 指令时，并不会马上停止所有的 worker，而是 master 重新加载配置文件后启动新的 worker，并告诉老的 worker 可以结束，从而达到不停机的效果。\n参考链接 The Architecture of Open Source Applications (Volume 2) nginx\nnginx为什么性能这么优越？\n","pubDate":"2023-08-17","title":"一篇文章入门 Nginx"},{"link":"https://cuctut.github.io/posts/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98+%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","plain":"问题概述 什么是缓存击穿？跟缓存雪崩一样，这些高大上的名字其实都是在说同一个问题：缓存失效。\n所谓缓存，是给 DB 降压的一种方案。我们想象这样一种情况：\n在你的 Redis 缓存中有一个热点数据 “坤坤背带裤”，日搜过百万，但是你不小心把两年半的过期时间设置成两天半，结果在缓存过期的那一刻，有大量的请求发现缓存中没有，直接“击穿”到 DB 中查询，造成瞬间 DB 请求量和压力暴增，DB直呼“击你太美”。\ntip 缓存击穿指的是针对某一个key的缓存失效了，而缓存雪崩则是很多keys。\n预防 设置热点数据不过期：当有变动需求时，需要用其他方式更新，不方便； 定时任务，更新缓存：解决1的情况； 设置互斥锁：当请求某个 key 时发现缓存没有，就给该 key 加锁，然后到数据库查询并缓存，期间其他请求上锁的 key 的请求无法处理，直接返回（牺牲少量用户的请求实现高性能） SpringCache 解决方案 利用 SpringCache 提供的注释，我们可以很轻松的将缓存同步。\n将 sync = true 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存。\n布隆过滤器 解决方案 现在我们修复了这个“坤坤背带裤”的问题，但有一个小黑子受不了真爱粉的热情，想将你的 DB 搞崩溃，但是他发现他发送的海量请求“坤坤背带裤”的请求都在缓存这里响应了，于是他伪造了一堆不存在的 keys 进行攻击，也就是说，黑客伪造了一个不存在的热点数据，这个时候缓存还是被击穿了，这个时候怎么办呢？\n很容易想到，可以在请求来时增加一个判断，不用查询DB就能判断这个数据是否存在，也就是增加一个轻量的过滤器：布隆过滤器。\n什么是布隆过滤器 1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。\n这种算法由一个二进制数组和一个Hash 算法组成，这个二进制数组就是 Redis 中的 Bitmaps 结构。\n图片中可以看到，某个 Set 中的元素通过 Hash 算法，映射到 Bitmaps 上，对应的下标为元素各自得到的 Hash 值，用1表示元素的存在；理想情况下，F 由于不在 Set 中，所以在查询时通过同样的 Hash 算法得到的结果是0，很容易通过 O(1) 复杂度判断他不存在 Set 中。\n这种方法避免不了 Hash 冲突的存在，如不存在的 D 碰巧和 C 的位置撞了，就会导致误判的问题，也就是说：\n通过 Hash 计算存在 Bitmaps 上不一定在集合中 通过 Hash 计算不在 Bitmaps 上一定不在集合中 我们正是利用第二点，可以减少很多不必要的查询，而对应第一点的解决方法，可以通过增加 Bitmaps 的大小和 Hash 的次数，让相撞的概率降低。\n在用户登录的情景也是一样的：\n","pubDate":"2023-08-16","title":"Redis缓存击穿问题+解决方案"},{"link":"https://cuctut.github.io/posts/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/","plain":"过期问题 Redis 所有数据结构都可以设置过期时间，当到期时会自动删除，但是有这种情况：当我们在同一时间有很多的 key 过期，在单线程情况下，大量的删除会带来线程的长时间占用（相较于读写操作），那么 Redis 采用了什么方案来解决这个问题呢？\n过期策略 首先需要知道的是：Redis 将所有设置有过期时间的 key 都放到独立的字典中进行管理。字典的存在不是为了统一的删除，Redis 采用了惰性删除和定期扫描删除的方式，将一次性的过期删除操作拆分成多次，从而避免大量删除影响性能。\n接下来我们来看看 Redis 的具体方案。\n惰性删除 惰性删除，顾名思义就是被动的、不预先的删除，让 key 只有在被访问时才会检查过期时间并判断是否删除。这种方式看似可以最大化节省资源，不用频繁去检查过期，但是，如果有大量的长时间不被访问的过期key存在时，这种惰性删除策略就会让内存资源被大量占用，很不友好。\n定期扫描删除 为了解决这个问题，Redis 结合采用了定期扫描删除的策略：\n在存放带有过期时间 key 的字典中，Redis 采用周期性扫描的方式，每次扫描不会遍历到字典中所有的key，而是采用一种简单的贪心策略：\n从字典中随机取20个keys； 删除所选keys中过期的key； 如果过期的key的占比超过1/4，重复12步骤； 从第三步操作不难看出，Redis 利用过期数据占比的方式，优化删除频率。\n这种循环最终会让字典中过期key的分布变得稀疏，但值得注意的是：极端情况下，当某一时间有大批大批的 keys 过期时，这种循坏删除的操作还是会导致占用线程的现象，另外，大量的内存释放会让内存管理器频繁的回收内存页，也要消耗一定的CPU资源。\n因此，在实际开发中，还是要尽量避免将大量的 keys 设置在同一时间，可以在设置过期时间时对其进行合理范围内的随机偏移，达到错峰删除。\n区别 惰性删除是被动的、零散的删除；定期扫描删除是主动的、批量的删除。\n从库的过期策略 如果搭建了主从结构，从库不会进行过期扫描。\n从库对过期的处理是被动的。当主库处理了到期的 key 时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令删除过期的 key。\n因为指令同步是异步进行的，所以主库过期的 key 的 del 指令没有及时同步到从库的话，会出现主从数据的不一致，某段时间内主库没有的数据在从库里还存在，集群环境分布式锁的算法漏洞就是因为这个同步延迟产生的。\n过期策略还远远不够？ 虽然 Redis 采用惰性删除和定期扫描删除，已经可以实现较高性能的过期 keys 删除，但再想象这样一种情况：如果某一段时间定期扫描删除漏掉了很多过期 keys 或来不及处理它们，这些 keys 也没有被访问所以走不了惰性删除，时间一长还是会导致大量的无效内存占用，需要一段时间来消化，严重点的话会让预设的内存耗尽。显然，我们还需要一个内存淘汰机制来应对这种情况。\n内存淘汰机制 当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换(swap)，交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用。\n在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小。当实际内存超出 maxmemory 时，Redis提供了几种可选策略(maxmemory-policy)来让用户决定该如何腾出新的空间以继续提供读写服务。\n8 种内存淘汰策略如下：\nnoeviction(默认)：不做任何的清理工作，在内存越限后所有写入操作会返回OOM(out of memory)，读操作能正常进行； volatile-lru(least recently used)：最近最少使用算法，从设置了过期时间的键中选择空转时间最长的，即最长没被使用的键值对清除掉； volatile-lfu(least frequently used)：最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉（区别在于时间和频次）； volatile-ttl：从设置了过期时间的键中选择过期时间最早的键值对清除； volatile-random：从设置了过期时间的键中，随机选择键进行清除； allkeys-lru：最近最少使用算法，从所有的键中选择空转时间最长的键值对清除； allkeys-lfu：最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除； allkeys-random：所有的键中，随机选择键进行删除； 注意：volatile 策略只会针对带过期时间的key进行淘汰，allkeys 策略会对所有的key进行淘汰。如果只是拿 Redis 做缓存，那应该使用 allkeys 策略，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，就使用 volatile 策略，这样可以保留没有设置过期时间的key，它们是永久的key 不会被 LRU 算法淘汰。\nLRU算法 实现LRU算法，除了需要 key/value 字典外，还需要附加一个链表，链表中的元素按照一定的顺序进行排列。在LRU算法中这个顺序就是最近一次使用的时间。\n当空间满的时候，会踢掉链表尾部的元素。当字典的某个元素被访问时，它在链表中的位置会被移动到表头。所以链表的元素排列顺序就是元素最近被访问的时间顺序，位于链表尾部的元素就是不常用的元素，会被优先踢掉。位于表头的元素就是最近刚刚被人用过的元素，所以暂时不会被踢。\n优化的近似LRU算法 Redis 使用的是一种近似 LRU 算法。之所以不使用 LRU 算法，是因为链表需要消耗大量的额外的内存，需要对现有的数据结构进行较大的改造。近似 LRU 算法则很简单，在现有数据结构的基础上使用随机采样法来淘汰元素，能达到和 LRU 算法非常近似的效果。\nRedis 为实现近似 LRU 算法，它给每个 key 增加了一个额外的小字段，这个字段的长度是 24 个 bit，也就是最后一次被访问的时间戳。当 Redis 执行写操作时，发现内存超出 maxmemory，就会执行一次 LRU 淘汰算法。这个算法也很简单，就一随机采样出5(可以配置maxmemory-samples)个key，然后淘汰掉最旧的key，如果淘汰后内存还是超出 maxmemory，那就继续随机采样淘汰，直到内存低于 maxmemory 为止。\n采样数量可以通过config文件修改，采样数量越大，越趋近于LRU算法。\n","pubDate":"2023-08-14","title":"Redis的过期策略以及内存淘汰机制"},{"link":"https://cuctut.github.io/posts/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E5%86%85%E5%AD%98+%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E4%B8%8D%E5%A4%9F/","plain":"概述 Redis 作为一个热门的内存数据库，以“快”字作为主打特点。为什么Redis如此快速？除了内存存储、单线程模型，还有什么更高级的黑科技？本文将更加深入的探讨Redis的一些设计和特性，解释了其高速背后的原因。\n内存存储 Redis的第一个秘诀在于其数据存储方式。与传统的磁盘存储不同，Redis将数据存储在内存中。内存访问速度远远快于磁盘访问速度，这使得Redis能够在微秒级别响应请求。虽然内存存储限制了Redis能够存储的数据量，但对于那些需要快速读写的数据，这是一个明智的权衡。\n单线程模型 Redis使用单线程模型来处理请求，这是其另一个速度优势的关键因素。虽然听起来似乎不合逻辑，但这实际上是有道理的。通过避免多线程之间的锁竞争和上下文切换，Redis能够保持更简单的代码结构，降低了开销，从而提高了性能。然而，这也意味着Redis在某些特定情况下可能会受到性能瓶颈的限制，特别是在高并发写入的情况下。\n可以看看我的另一篇文章：为什么 Redis 选择单线程模型，又走向多线程 ？\nI/O模型 单线程模型的使用使得 Redis 选择使用非阻塞的I/O模型，可以高效地处理网络请求。它采用了多路复用技术，允许单个线程同时处理多个客户端连接，从而减少了线程切换的开销，提高了并发性能。\n数据结构的优化 Redis 并不仅限于简单的键值存储，它还支持多种复杂的数据结构，如字符串、列表、哈希、集合、有序集合等。每种数据结构都经过了高度优化，使得它们在不同的应用场景下能够达到最佳的性能表现。这里拿比较经典的哈希来举例。\n渐进式的ReHash Redis 使用链式哈希的方式实现 Hash，在哈希冲突达到需要扩容时，Redis 不是采用直接阻塞并 ReHash 的方法，而是采用渐进式的ReHash。\n首先，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。\n一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多， Redis 开始执行 rehash。\n给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍 把哈希表1中的数据重新映射并拷贝到哈希表2中 释放哈希表1的空间 在上面的第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。\n在 Redis 开始执行 ReHash，Redis仍然正常处理客户端请求，但是要加入一个额外的处理：\n处理第1个请求时，把哈希表1中的第1个索引位置上的所有 entries 拷贝到哈希表2中 处理第2个请求时，把哈希表1中的第2个索引位置上的所有 entries 拷贝到哈希表2中 \u0026hellip;\n如此循环，直到把所有的索引位置的数据都拷贝到哈希表2中。这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。所以这里基本上也可以确保根据 key 找 value 的操作在 O (1) 左右。\ntip 不过这里要注意，如果 Redis 中有海量的 key 值的话，这个 ReHash 过程会很长很长，虽然采用渐进式 ReHash，但在 ReHash 的过程中还是会导致请求有不小的卡顿。并且像一些统计命令也会非常卡顿：比如 keys，按照 Redis 的配置每个实例能存储的最大的 key 的数量为2的32次方，即2.5亿，但是尽量把key的数量控制在千万以下，这样就可以避免Rehash 导致的卡顿问题，如果数量确实比较多，建议采用分区hash存储。\n也可以看看这篇文章，了解其他例如动态字符串、压缩链表等优化：\nRedis进阶三之底层存储数据结构及内存优化\n其他优化 我们平时使用系统时间戳时，常常是不假思索地使用System.currentTimelnMillis或者time.time()来获取系统的毫秒时间戳。Redis不能这样，因为每一次获取系统时间戳都是一次系统调用，系统调用相对来说是比较费时间的，作为单线程的Redis承受不起，所以它需要对时间进行缓存，由一个定时任务，每毫秒更新一次时间缓存，获取时间都是从缓存中直接拿。\n","pubDate":"2023-08-13","title":"Redis为什么快？内存+多线程还不够！"},{"link":"https://cuctut.github.io/posts/nacos%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/","plain":"长轮询 Nacos Client 端是采用长轮训的方式向 Nacos Server 端发起配置更新查询的功能。所谓长轮训，（如图）就是客户端发起一次轮训请求到服务端，当服务端配置没有任何变更的时候，这个连接一直打开。这样减少了 pull 轮询次数，又利用了长连接的优势，很好的实现了配置的动态更新同步功能。\n直到服务端有配置或者连接超时后返回。\n比较 Nacos Client 端需要获取服务端变更的配置，前提是要有一个比较，也就是拿客户端本地的配置信息和服务端的配置信息进行比较。\n一旦发现和服务端的配置有差异，就表示服务端配置有更新，于是把更新的配置拉到本地。\n有可能因为客户端配置比较多，导致比较的时间较长，使得配置同步较慢的问题。\n优化 Nacos 针对客户端配置比较多的情况，做了两个方面的优化。\n减少网络通信的数据量： 客户端把需要进行比较的配置进行分片，每一个分片大小是 3000，也就是说，每次最多拿 3000 个配置去 Nacos Server 端进行比较。 分阶段进行比较和更新： 第一阶段，客户端把这 3000 个配置的 key 以及对应的 value 值的 md5 拼接成一个字符串，然后发送到 Nacos Server 端进行判断，服务端会逐个比较这些配置中 md5 不同的 key，把存在更新的 key 返回给客户端。 第二阶段，客户端拿到这些变更的 key，循环逐个去调用服务单获取这些 key 的 value值。 tip 把一次大的数据包通信拆分成了多次小的数据包通信。虽然会增加网络通信次数，但是对整体的性能有较大的提升。\n更多参考 Nacos配置中心原理-微信公众号文章\n","pubDate":"2023-06-11","title":"Nacos配置热更新原理"},{"link":"https://cuctut.github.io/posts/sql%E8%AF%AD%E6%B3%95/","plain":"前言 只对不常使用的和比较深的概念做摘录，方便温习，具体例子详见出处链接。\nSQL语法基础知识总结 链接 -\u0026gt; SQL语法基础知识总结\n-\u0026gt; MySQL 索引详解\n-\u0026gt; 后端程序员必备：SQL 高性能优化指南！35+条优化建议立马 GET!\n-\u0026gt; 后端程序员必备：书写高质量 SQL 的 30 条建议\n-\u0026gt; SQL常见面试题总结\n数据定义 视图（VIEW） 定义：\n视图是基于 SQL 语句的结果集的可视化的表。 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 作用：\n简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 创建视图 1 2 3 4 CREATE VIEW top_10_user_view AS SELECT id, username FROM user WHERE id \u0026lt; 10; 删除视图 1 DROP VIEW top_10_user_view; 索引（INDEX） 索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。\n优点：\n使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点：\n创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 但是，使用索引一定能提高查询性能吗?\n大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。\n关于索引的详细介绍，请看:\n-\u0026gt; MySQL 索引详解\n创建索引 1 2 CREATE INDEX user_index ON user (id); 添加索引 1 ALTER table user ADD INDEX user_index(id) 创建唯一索引 1 2 CREATE UNIQUE INDEX user_index ON user (id); 删除索引 1 2 ALTER TABLE user DROP INDEX user_index; 约束 SQL 约束用于规定表中的数据规则。\n如果存在违反约束的数据行为，行为会被约束终止。\n约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。\n约束类型：\nNOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 创建表时使用约束条件：\n1 2 3 4 5 6 7 8 CREATE TABLE Users ( Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \u0026#39;自增Id\u0026#39;, Username VARCHAR(64) NOT NULL UNIQUE DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;用户名\u0026#39;, Password VARCHAR(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;密码\u0026#39;, Email VARCHAR(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;邮箱地址\u0026#39;, Enabled TINYINT(4) DEFAULT NULL COMMENT \u0026#39;是否有效\u0026#39;, PRIMARY KEY (Id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\u0026#39;用户表\u0026#39;; 事务处理 Transaction control lauguage，事务控制语言， TCL 。TCL 的主要功能是管理数据库中的事务。\n不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。\n通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。\n指令：\nSTART TRANSACTION - 指令用于标记事务的起始点。 SAVEPOINT - 指令用于创建保留点。 ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。 COMMIT - 提交事务。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 开始事务 START TRANSACTION; -- 插入操作 A INSERT INTO `user` VALUES (1, \u0026#39;root1\u0026#39;, \u0026#39;root1\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); -- 创建保留点 updateA SAVEPOINT updateA; -- 插入操作 B INSERT INTO `user` VALUES (2, \u0026#39;root2\u0026#39;, \u0026#39;root2\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); -- 回滚到保留点 updateA ROLLBACK TO updateA; -- 提交事务，只有操作 A 生效 COMMIT; 权限控制 要授予用户帐户权限，可以用GRANT命令。有撤销用户的权限，可以用REVOKE命令。这里以 MySQl 为例，介绍权限控制实际应用。\nGRANT授予权限语法：\n1 2 3 4 GRANT privilege,[privilege],.. ON privilege_level TO user [IDENTIFIED BY password] [REQUIRE tsl_option] [WITH [GRANT_OPTION | resource_option]]; 简单解释一下：\n在GRANT关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。 ON privilege_level 确定权限应用级别。MySQL 支持 global（*.*），database（database.*），table（database.table）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。 user 是要授予权限的用户。如果用户已存在，则GRANT语句将修改其权限。否则，GRANT语句将创建一个新用户。可选子句IDENTIFIED BY允许您为用户设置新的密码。 REQUIRE tsl_option指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。 可选 WITH GRANT OPTION 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用WITH子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。 REVOKE 撤销权限语法：\n1 2 3 4 REVOKE privilege_type [(column_list)] [, priv_type [(column_list)]]... ON [object_type] privilege_level FROM user [, user]... 简单解释一下：\n在 REVOKE 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。 指定在 ON 子句中撤销特权的特权级别。 指定要撤消 FROM 子句中的权限的用户帐户。 GRANT 和 REVOKE 可在几个层次上控制访问权限：\n整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 新创建的账户没有任何权限。账户用 username@host 的形式定义，username@% 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。\n1 2 USE mysql; SELECT user FROM user; 下表说明了可用于GRANT和REVOKE语句的所有允许权限：\n特权 说明 级别 全局 数据库 表 列 程序 代理 ALL [PRIVILEGES] 授予除 GRANT OPTION 之外的指定访问级别的所有权限 ALTER 允许用户使用 ALTER TABLE 语句 X X X ALTER ROUTINE 允许用户更改或删除存储的例程 X X X CREATE 允许用户创建数据库和表 X X X CREATE ROUTINE 允许用户创建存储的例程 X X CREATE TABLESPACE 允许用户创建，更改或删除表空间和日志文件组 X CREATE TEMPORARY TABLES 允许用户使用 CREATE TEMPORARY TABLE 创建临时表 X X CREATE USER 允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。 X CREATE VIEW 允许用户创建或修改视图。 X X X DELETE 允许用户使用 DELETE X X X DROP 允许用户删除数据库，表和视图 X X X EVENT 启用事件计划程序的事件使用。 X X EXECUTE 允许用户执行存储的例程 X X X FILE 允许用户读取数据库目录中的任何文件。 X GRANT OPTION 允许用户拥有授予或撤消其他帐户权限的权限。 X X X X X INDEX 允许用户创建或删除索引。 X X X INSERT 允许用户使用 INSERT 语句 X X X X LOCK TABLES 允许用户对具有 SELECT 权限的表使用 LOCK TABLES X X PROCESS 允许用户使用 SHOW PROCESSLIST 语句查看所有进程。 X PROXY 启用用户代理。 REFERENCES 允许用户创建外键 X X X X RELOAD 允许用户使用 FLUSH 操作 X REPLICATION CLIENT 允许用户查询以查看主服务器或从属服务器的位置 X REPLICATION SLAVE 允许用户使用复制从属从主服务器读取二进制日志事件。 X SELECT 允许用户使用 SELECT 语句 X X X X SHOW DATABASES 允许用户显示所有数据库 X SHOW VIEW 允许用户使用 SHOW CREATE VIEW 语句 X X X SHUTDOWN 允许用户使用 mysqladmin shutdown 命令 X SUPER 允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令 X TRIGGER 允许用户使用 TRIGGER 操作。 X X X UPDATE 允许用户使用 UPDATE 语句 X X X X USAGE 相当于“没有特权” 创建账户 1 CREATE USER myuser IDENTIFIED BY \u0026#39;mypassword\u0026#39;; 修改账户名 1 2 UPDATE user SET user=\u0026#39;newuser\u0026#39; WHERE user=\u0026#39;myuser\u0026#39;; FLUSH PRIVILEGES; 删除账户 1 DROP USER myuser; 查看权限 1 SHOW GRANTS FOR myuser; 授予权限 1 GRANT SELECT, INSERT ON *.* TO myuser; 删除权限 1 REVOKE SELECT, INSERT ON *.* FROM myuser; 更改密码 1 SET PASSWORD FOR myuser = \u0026#39;mypass\u0026#39;; SQL语法应用 比较重要的：理解分组（GROUP）、连接（JOIN）以及他们附带的USING、ON、HAVING等等用法！\n-\u0026gt; SQL常见面试题总结\n","pubDate":"2023-05-25","title":"SQL语法"},{"link":"https://cuctut.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","plain":"数据库基础知识总结 链接 包括数据库、数据库管理系统、数据库系统、数据库管理员、元组、各种码、范式的概念。\n-\u0026gt; 数据库基础\n为什么不推荐使用外键与级联？ 对于外键和级联，阿里巴巴开发手册这样说到：\n【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度\n为什么不要用外键呢？大部分人可能会这样回答：\n增加了复杂性： a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。 增加了额外工作：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。） 对分库分表不友好：因为分库分表下外键是无法生效的。 \u0026hellip;\u0026hellip; 我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：\n保证了数据库数据的一致性和完整性； 级联操作方便，减轻了程序代码量； \u0026hellip;\u0026hellip; 所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理。\n如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。\n什么是存储过程? 我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。\n存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n阿里巴巴 Java 开发手册里要求禁止使用存储过程。\ndrop、delete 与 truncate 区别？ 用法不同 drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。 truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。 truncate 和不带 where子句的 delete、以及 drop 都会删除表内的数据，但是 truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行drop 之后对应的表不复存在。\n属于不同的数据库语言 truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。\nDML 语句和 DDL 语句区别：\nDML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。 DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。 另外，由于select不会对表进行破坏，所以有的地方也会把select单独区分开叫做数据库查询语言 DQL（Data Query Language）。\n执行速度不同 一般来说：drop \u0026gt; truncate \u0026gt; delete（这个我没有设计测试过）。\ndelete命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。 truncate命令执行的时候不会产生数据库日志，因此比delete要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。 drop命令会把表占用的空间全部释放掉。 Tips：你应该更多地关注在使用场景上，而不是执行效率。\nNoSQL基础知识总结 NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n-\u0026gt;NoSQL基础\n字符集详解 -\u0026gt;字符集详解\n","pubDate":"2023-05-25","title":"数据库基础"},{"link":"https://cuctut.github.io/posts/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%843%E7%A7%8D%E5%8E%9F%E5%9B%A0/","plain":"前言 自增主键的特点是当表中每新增一条记录时，主键值会根据自增步长自动叠加，通常会将自增步长设置1，也就是说自增主键值是连续的。那么MySQL自增主键值一定会连续吗？今天这篇文章就来说说这个问题，看看什么情况下自增主键会出现不连续?\n实验 数据准备 1 2 3 4 5 6 7 8 9 drop TABLE increnment_test; -- 创建包含白增主键的表 CREATE TABLE increnment_test ( id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, col1 INT(11) NOT NULL, col2 INT(11) NOT NULL, col3 INT(11) NOT NULL, UNIQUE KEY (col1) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; 唯一键冲突 比如increnment_test表中已经存在了col1为 3 的记录，我们继续插入col1为 3 的记录，此时会出现唯一键冲突插入报错，但是没有将自增值再改回去。重新插入col1为 4 的值，此时对应的id为 5;\n1 2 3 4 select * from increnmont_test; INSERT INTO increnment test (coll, col2, col3) VALUES (3, 3, 3); INSERT INTO increnment_test (col1, co12, col3) VALUES (4, 4, 4); 结果：理想下应该id为4，现实是5\nid col1 col2 col3 1 1 1 1 2 2 2 2 3 3 3 3 5 4 4 4 原因：InnoDB引擎的自增值修改流程\n执行器调用InnoDB引擎接口将分析器优化后的SQL传入,并将值(3,3,3)一起传过去 InnoDB发现用户没有指定自增id列,会先获取表increnment_test当前的自增值3 将ID列补充完整,并且将自增值填入(3,3,3,3) 然后将表的自增值改成4 继续执行插入数据操作; 唯一键冲突，插入失败，但自增值还是4，不回退 继续插入(4,4,4)，重复上面流程，使用4+1=5作为自增值 tip 自增字段值的生成是由存储引擎自动完成的,而不是由优化器完成的。因此,在执行SQL语句时,即使未指定自增字段列,也不会对性能产生任何影响。\n事务回滚 开启一个事务插入col1为 6 的数据，然后进行回滚。回滚后重新插入col1为 6 的记录，此时col1为 6 的id值为 7\n1 2 3 4 5 6 7 BEGIN; INSERT INTO increnment_test (col1, col2, col3) VALUES(6, 6, 6); ROLLBACK; BEGIN; INSERT INTO increnment_test (col1, col2, col3) VALUES(6, 6, 6); COMMIT; 结果：理想下应该id为6，现实是7\nid col1 col2 col3 1 1 1 1 2 2 2 2 3 3 3 3 5 4 4 4 7 6 6 6 原因和唯一键冲突一致，都是自增值没有回退导致。\n批量插入数据 创建一个和increnment_test相同结构的表increnment_test2，将前者的内容全部插入到后者，再插入一条数据，如下：\n1 2 3 4 5 6 7 drop table increnment_test2; create table increnment_test2 like increnment_test; INSERT INTO increnment_test2 (col1, col2, col3) SELECT col1, col2, col3 FROM increnment_test; INSERT INTO increnment_test2 (col1, col2, col3) VALUES (8, 8, 8); SELECT * FROM increnment_test2; 结果：理想下应该id为6，现实是8\n（前面1~5的id是新表increnment_test2自增分配的，不复制increnment_test的）\nid col1 col2 col3 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 6 6 6 8 8 8 8 原因：\n对于批量插入数据的语句，如：insert … select、replace … select 和 load data 语句，这时不确定要插入多少条数据，所以无法一次性准确地申请对应个数的id，此时 MySQL 有一个批量申请自增 id 的策略：\nSQL语句执行过程中,第1次申请自增id,会分配1个; 1个用完以后，第2次申请自增id，会分配2个； 2个用完以后，第3次申请自增 id，会分配4个； 依此类推，同一个语句去申请自增 id，每次申请到的自增id个数都是上一次的两倍。\n对于此例，第一次分配的是1，第二次分配的是2、3，第三次是4、5、6、7，在插入(8, 8, 8)前，自增id只用到5，而6、7已经分配出去，继续插入单条，自增后直接分配到8，所以会从8开始（不会分配8~15，因为不是批量插入）\ntip 通过insert into table(col1,col2) values(a,b),(b,c)\u0026hellip;这种一次插入多条数据时除外，因为这种方式插入多条数据时，申请id的个数是可以准确计算的。\n扩展 摘自https://www.modb.pro/db/131854，里面的扩展部分关于自增值的修改策略虽不重要，但也很受益。\n自增值的保存位置 我们可以通过 show create table table_name 命令查看某个表当前的 AUTO_IINCREMENT 值，那么是不是这个自增值和表结构定义保存在一起？其实并不是，表结构定义保存在后缀为.frm的文件中，而自增值并不在。\nMyISAM 引擎的自增值保存在数据文件中。\nInnoDB 引擎的自增值，在 MySQL 5.7 及之前的版本是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是：\n在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。\n在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。\n为什么不在插入数据失败时将自增值改回去？ 假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。\n事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。 事务 B 正确提交了，但事务 A 出现了唯一键冲突。 如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。 接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。 而为了解决这个主键冲突，有两种方法：\n每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。 把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。 可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增 id 回退”的前提导致的。\n因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。\n自增锁 MySQL里面有一种锁叫自增锁，是在申请自增主键值的时候填加的锁，但这种锁并不是事务锁，在 MySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。\n显然，这样设计会影响并发度。MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。(8.x版本这个参数的默认值已经改为了2)\n这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁； 这个参数的值被设置为 1 时：普通 insert 语句，自增锁在申请之后就马上释放；类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放； 这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。 为什么5.1.22引入innodb_autoinc_lock_mode参数时默认值为1，而8.0将默认值设改成了2 来自ChatGPT：\n在MySQL数据库中，innodb_autoinc_lock_mode参数用于控制InnoDB存储引擎中自增列（auto-increment column）的锁定方式。\n在版本5.1.22中引入innodb_autoinc_lock_mode参数时，其默认值被设置为1。这意味着在插入新行时，InnoDB将使用传统的表级锁（table-level lock）来锁定整个表，以确保自增列的唯一性。这种锁定方式可以有效地保证自增列的唯一性，但在并发插入时可能会导致性能瓶颈，因为每次插入操作都需要锁定整个表。\n然而，在MySQL 8.0版本中，innodb_autoinc_lock_mode参数的默认值被改为2。这意味着InnoDB现在使用更为灵活的行级锁（row-level lock）来锁定自增列。使用行级锁可以更好地支持并发插入操作，因为不同的插入操作可以同时进行，而不需要等待对整个表的锁定。\n通过将innodb_autoinc_lock_mode参数的默认值从1更改为2，MySQL 8.0提供了更好的并发性能，尤其在高并发的写入负载下。但需要注意的是，这可能会导致一些特殊情况下的自增列值不连续（例如，回滚的事务可能导致自增值未被使用），因此在特定应用场景中可能需要进行适当的调整。\n总结而言，MySQL 8.0将innodb_autoinc_lock_mode参数的默认值改为2是为了提高并发插入的性能，但也需要根据具体情况进行评估和调整。\n","pubDate":"2023-05-23","title":"MySQL自增主键不连续的3种原因"},{"link":"https://cuctut.github.io/posts/spring%E4%BA%8B%E5%8A%A1/","plain":"什么是事务？ 事务是逻辑上的一组操作，要么都执行，要么都不执行。\n我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 savePerson() 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。\n1 2 3 4 public void savePerson() { personDao.save(person); personDetailDao.save(personDetail); } 事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 innodb引擎。但是，如果把数据库引擎变为 myisam，那么程序也就不再支持事务了！\n事务的特性（ACID） 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 tip 这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！\nMySQL 怎么保证原子性的？ 我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。\nSpring中的事务管理 Spring事务的本质是数据库对事务的支持。没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。\n两种开发方式实现事务管理 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。 大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。\n编程式事务管理 通过 TransactionTemplate 或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于理解 Spring 事务管理原理有帮助。\n使用 TransactionTemplate 进行编程式事务管理的示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Autowired private TransactionTemplate transactionTemplate; public void testTransaction() { transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { try { // .... 业务代码 } catch (Exception e){ //回滚 transactionStatus.setRollbackOnly(); } } }); } 使用 TransactionManager 进行编程式事务管理的示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private PlatformTransactionManager transactionManager; public void testTransaction() { TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { // .... 业务代码 transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } } 声明式事务管理 推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional的全注解方式使用最多）。\n使用 @Transactional 注解进行事务管理的示例代码如下：\n1 2 3 4 5 6 7 8 @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something B b = new B(); C c = new C(); b.bMethod(); c.cMethod(); } Spring 事务管理接口介绍 Spring 框架中，事务管理相关最重要的 3 个接口如下：\nPlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心，是事务上层的管理者。 TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)，是事务的描述。 TransactionStatus：事务运行状态，是事务的描述。 PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。\nPlatformTransactionManager Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是：PlatformTransactionManager 。\n通过这个接口，Spring 为各个平台如：\nJDBC (DataSourceTransactionManager)\nHibernate(HibernateTransactionManager)\nJPA (JpaTransactionManager)\n等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。\nPlatformTransactionManager 接口的具体实现如下: PlatformTransactionManager 接口中定义了三个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 package org.springframework.transaction; import org.springframework.lang.Nullable; public interface PlatformTransactionManager { //获得事务 TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException; //提交事务 void commit(TransactionStatus var1) throws TransactionException; //回滚事务 void rollback(TransactionStatus var1) throws TransactionException; } TransactionDefinition 事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition 类 ，这个类就定义了一些基本的事务属性。\n事务属性包含了 5 个方面：\n隔离级别 传播行为 回滚规则 是否只读 事务超时 TransactionDefinition 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.springframework.transaction; import org.springframework.lang.Nullable; public interface TransactionDefinition { int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; int ISOLATION_DEFAULT = -1; int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; int TIMEOUT_DEFAULT = -1; // 返回事务的传播行为，默认值为 REQUIRED。 int getPropagationBehavior(); //返回事务的隔离级别，默认值是 DEFAULT int getIsolationLevel(); // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。 int getTimeout(); // 返回是否为只读事务，默认值为 false boolean isReadOnly(); @Nullable String getName(); } TransactionStatus TransactionStatus 接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息.PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。\nTransactionStatus 接口内容如下：\n1 2 3 4 5 6 7 public interface TransactionStatus{ boolean isNewTransaction(); // 是否是新的事务 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成 } 事务属性详解 事务属性是在 TransactionDefinition 中定义的，比较重要的是事务传播行为和事务隔离级别\n事务传播行为 事务传播行为：当多个事务同时存在的时候，spring如何处理这些事务的行为，解决的是业务层方法之间互相调用的事务问题。\ntip 举个例子：我们在 A 类的 aMethod()方法中调用了 B 类的 bMethod() 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 bMethod()如果发生异常需要回滚，如何配置事务传播行为才能让 aMethod()也跟着回滚呢？这个时候就需要事务传播行为的知识了。\n在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：\n1 2 3 4 5 6 7 8 9 10 public interface TransactionDefinition { int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; ...... } 为了方便使用，Spring 相应地定义了一个枚举类：Propagation\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package org.springframework.transaction.annotation; import org.springframework.transaction.TransactionDefinition; public enum Propagation { REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED), SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS), MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY), REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW), NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED), NEVER(TransactionDefinition.PROPAGATION_NEVER), NESTED(TransactionDefinition.PROPAGATION_NESTED); private final int value; Propagation(int value) { this.value = value; } public int value() { return this.value; } } 1. REQUIRED 使用的最多的一个事务传播行为，我们平时经常使用的 @Transactional 注解默认使用就是这个事务传播行为。\n如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\n也就是说：如果外部方法没有开启事务的话，Propagation.REQUIRED 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。如果外部方法开启事务并且被 Propagation.REQUIRED 的话，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。举个例子：如果我们上面的 aMethod() 和 bMethod() 使用的都是 PROPAGATION_REQUIRED 传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service Class A { @Autowired B b; @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something b.bMethod(); } } @Service Class B { @Transactional(propagation = Propagation.REQUIRED) public void bMethod { //do something } } 2. REQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。\n举个例子：如果我们上面的 bMethod() 使用 PROPAGATION_REQUIRES_NEW 事务传播行为修饰， aMethod 还是用 PROPAGATION_REQUIRED 修饰的话。如果 aMethod() 发生异常回滚， bMethod() 不会跟着回滚，因为 bMethod() 开启了独立的事务。但是，如果 bMethod() 抛出了未被捕获的异常并且这个异常满足事务回滚规则的话, aMethod() 同样也会回滚，因为这个异常被 aMethod() 的事务管理机制检测到了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service Class A { @Autowired B b; @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something b.bMethod(); } } @Service Class B { @Transactional(propagation = Propagation.REQUIRED_NEW) public void bMethod { //do something } } 3. NESTED 如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与 REQUIRED 类似的操作。也就是说：在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。如果外部方法无事务，则单独开启一个事务，与 REQUIRED 类似。\n这里还是简单举个例子：如果 bMethod() 回滚的话，aMethod()不会回滚。如果 aMethod() 回滚的话，bMethod()会回滚。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service Class A { @Autowired B b; @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something b.bMethod(); } } @Service Class B { @Transactional(propagation = Propagation.NESTED) public void bMethod { //do something } } 4. MANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n这个使用的很少，就不举例子来说了。\n5. 其他 若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。 SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。\n更多关于事务传播行为的内容请看这篇文章：\n《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》\n事务隔离级别 TransactionDefinition 接口中定义了五个表示隔离级别的常量：\n1 2 3 4 5 6 7 8 9 public interface TransactionDefinition { ...... int ISOLATION_DEFAULT = -1; int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; ...... } 为了方便使用，Spring 也相应地定义了一个枚举类： Isolation\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public enum Isolation { DEFAULT(TransactionDefinition.ISOLATION_DEFAULT), READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED), READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED), REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ), SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); private final int value; Isolation(int value) { this.value = value; } public int value() { return this.value; } } DEFAULT : 使用后端数据库默认的隔离级别，MySQL 默认采用 REPEATABLE_READ 隔离级别，Oracle 默认采用READ_COMMITTED 隔离级别 READ_UNCOMMITTED : 最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 相关阅读：MySQL 事务隔离级别详解\n事务超时属性 所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为-1，这表示事务的超时时间取决于底层事务系统或者没有超时时间。\n事务只读属性 1 2 3 4 5 6 7 8 9 10 package org.springframework.transaction; import org.springframework.lang.Nullable; public interface TransactionDefinition { ...... // 返回是否为只读事务，默认值为 false boolean isReadOnly(); } 对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。\n为什么一个数据查询操作还要启用事务支持呢？\n拿 MySQL 的 innodb 举例子\ntip MySQL 默认对每一个新建立的连接都启用了 autocommit 模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。\n但是，如果你给方法加上了 Transactional 注解的话，这个方法执行的所有sql会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。如果不加 Transactional ，每条sql会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。\n关于事务只读属性，其他人的解答：\n如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性； 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持# 事务回滚规则 事务回滚规则 这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（RuntimeException 的子类，可自定义异常类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。 如果你想要回滚你定义的特定的异常类型的话，可以这样：\n1 @Transactional(rollbackFor= MyException.class) @Transactional 注解 @Transactional 的作用范围 方法：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。 类：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。 接口：不推荐在接口上使用。 @Transactional 的常用配置参数 @Transactional 注解源码如下，里面包含了基本事务属性的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Transactional { @AliasFor(\u0026#34;transactionManager\u0026#34;) String value() default \u0026#34;\u0026#34;; @AliasFor(\u0026#34;value\u0026#34;) String transactionManager() default \u0026#34;\u0026#34;; Propagation propagation() default Propagation.REQUIRED; Isolation isolation() default Isolation.DEFAULT; int timeout() default TransactionDefinition.TIMEOUT_DEFAULT; boolean readOnly() default false; Class\u0026lt;? extends Throwable\u0026gt;[] rollbackFor() default {}; String[] rollbackForClassName() default {}; Class\u0026lt;? extends Throwable\u0026gt;[] noRollbackFor() default {}; String[] noRollbackForClassName() default {}; } 属性名 说明 propagation 事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过 isolation 事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过 timeout 事务的超时时间，默认为-1（不会超时）。超时但事务没完成，则自动回滚。 readOnly 指定事务是否为只读事务，默认值为 false。 rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。 @Transactional 事务注解原理 @Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。\n如果一个类或者一个类中的 public 方法上被标注 @Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被 @Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke() 方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。\nSpring AOP 自调用问题 若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效。\ntip 这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。\nMyService 类中的method1()调用method2()就会导致method2()的事务失效。\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class MyService { private void method1() { method2(); //...... } @Transactional public void method2() { //...... } } 解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。\n@Transactional 的使用注意事项总结 @Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用； 避免同一个类中调用 @Transactional 注解的方法，这样会导致事务失效； 正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败; 被 @Transactional 注解的方法所在的类必须被 Spring 管理，否则不生效； 底层使用的数据库必须支持事务机制，否则不生效； 参考资料 Spring 事务详解\n参考\n","pubDate":"2023-05-23","title":"Spring事务"},{"link":"https://cuctut.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88-redis-%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%8F%88%E8%B5%B0%E5%90%91%E5%A4%9A%E7%BA%BF%E7%A8%8B-/","plain":"概述 Redis 作为广为人知的内存数据库，在玩具项目和复杂的工业级别项目中都看到它的身影，然而 Redis 一开始却是使用单线程模型进行设计的，这与很多人固有的观念有所冲突，为什么单线程的程序能够抗住每秒几百万的请求量呢？这也是我们今天要讨论的问题之一。\n除此之外，Redis 4.0 之后的版本却“抛弃”了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性使用多线程模型，这一看似有些矛盾的设计决策是今天需要讨论的另一个问题。\n为什么 Redis 在最初的版本中选择单线程模型？ 为什么 Redis 在 4.0 之后的版本中加入了多线程的支持？ tip However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.\n设计 虽然 Redis 在较新的版本中引入了多线程，不过是在部分命令上引入的，其中包括非阻塞的删除操作，在整体的架构设计上，主处理程序还是单线程模型的；由此看来，我们今天想要分析的两个问题可以简化成：\n为什么 Redis 服务使用单线程模型处理绝大多数的网络请求？ 为什么 Redis 服务增加了多个非阻塞的删除操作，例如：UNLINK、FLUSHALL ASYNC 和 FLUSHDB ASYNC？ 接下来的两个小节将从多个角度分析这两个问题。\n单线程模型 Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，作者分析了相关的资料，发现其中最重要的几个原因如下：\n使用单线程模型能带来更好的可维护性，方便开发和调试； 使用单线程模型也能并发的处理客户端的请求； Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU； 上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里我们会按顺序介绍上述的几个原因。\n可维护性 多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。\n有得有失，多线程维护性不如单线程。引入了多线程，我们就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，我们会需要在可能被并发读写的变量上增加互斥锁；在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。\n并发处理 使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制 并发处理来自客户端的多个连接，同时等待多个连接发送的请求。\n在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。\n使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。\n性能瓶颈 最后要介绍的其实就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕我们在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。\ntip It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.\n如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。\n简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。\ntip AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。\n另外，使用多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的性能开销，其中包括：\n保存线程 1 的执行上下文； 加载线程 2 的执行上下文； 频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。\n引入多线程 Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，也就是我们在上面提到的 UNLINK、FLUSHALL ASYNC 和 FLUSHDB ASYNC，我们为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？\n我们可以在 Redis 在中使用 DEL 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。\n但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。\n然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 UNLINK 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。\n总结 Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。\nReference 为什么 Redis 选择单线程模型\n","pubDate":"2022-08-12","title":"为什么 Redis 选择单线程模型，又走向多线程 ？"},{"link":"https://cuctut.github.io/posts/aop%E6%A6%82%E5%BF%B5/","plain":"AOP A OP，即一个OP，指一个原批（误）\n什么是AOP AOP，Aspect Oriented Programming，面向切面编程，是面向对象编程 OOP 的升华。\nOOP 是纵向对某事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。\nAOP 是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程。\nAOP中的相关概念 概念 单词 解释 目标对象 Target 被增强的方法所在的对象 代理对象 Proxy 对目标对象进行增强后的对象，客户端实际调用的对象 连接点 Joinpoint 目标对象中可以被增强的方法 切入点 Pointcut 目标对象中实际被增强的方法 通知/增强 Advice 增强部分的代码逻辑 切面 Aspect 增强和切入点的组合 织入 Weaving 将通知和切入点组合动态组合的过程 具体解释 切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n通知（Advice）：在AOP术语中，切面的工作被称为通知。\n切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。\n引入（Introduction）：引入允许我们向现有类添加新方法或属性。\n目标对象（Target Object）：被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced）对象。既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied）对象。\n织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：\n编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面 Spring AOP 通知类型 在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过 Spring AOP 框架触发的代码段。\nSpring切面可以应用5种类型的通知：\n前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning ）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 AOP 代理模式 一个OP自身精力有限，想继续肝下去需要请OP小代帮忙肝圣遗物（真）\nAOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。\nSpring AOP 和 AspectJ AOP 区别 AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为编译时增强，他会在编译阶段将 AspectJ (切面)织入到 Java 字节码中，运行的时候就是增强之后的 AOP 对象。\nSpring AOP 使用的动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。\n静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。\nwarning 因为 Spring 基于动态代理，所以 Spring 只支持方法连接点。Spring 缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用 Aspect 来补充。\nJDK 动态代理 和 CGLIB 动态代理的区别 Spring AOP 中的动态代理主要有两种方式，JDK 动态代理 和 CGLIB 动态代理：\nJDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler 动态创建一个符合某一接口的的实例, 生成目标类的代理对象。如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。\nCGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。\n其他 应用 tip Notion 笔记，一些网络代理节点可能无法访问，如在clash中要切换到DIRECT模式\n基于 xml 配置 AOP\n基于注解配置AOP\n关注点和横切关注的区别 关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 参考资料 83-Spring的AOP开发-模拟AOP思想实现方案_哔哩哔哩_bilibili\n","pubDate":"2022-05-22","title":"AOP概念"},{"link":"https://cuctut.github.io/posts/bean%E6%A6%82%E5%BF%B5/","plain":"什么是 Spring Bean？ Spring Bean 是指在Spring容器中被管理的对象。可以是任何的Java对象，如实体类、服务类、数据访问对象(DAO)等。它们被 Spring IOC 容器初始化，装配，和管理。这些 Bean 根据容器中配置的元数据创建。比如，以 XML 文件中的形式定义。\ntip 传统 Java Bean 由开发人员手动创建和管理生命周期，手动处理依赖关系，配置通常在代码中直接进行，维护性差。由于没有 AOP 概念，若要实现诸如事务管理、日志记录等横切功能，传统 Java Bean 通常需要开发人员手动编写和管理横切逻辑。而 Spring Bean 的特点解决了这些问题。\nBean的特点 Spring Bean具有以下特点：\n生命周期管理：Spring 容器负责Bean的生命周期，它负责在需要时创建Bean实例、初始化 Bean、将依赖注入到 Bean 中以及在不再需要时销毁 Bean 实例。 依赖注入：Spring 容器通过依赖注入机制自动解决 Bean 之间的依赖关系。这意味着你可以使用注解或配置将其他 Bean 注入到你的 Bean 中，从而实现解耦和灵活性。 配置灵活性：Spring 容器允许通过配置文件或注解来定义 Bean 及其属性。这使得你可以轻松修改 Bean 的配置，而无需修改源代码。 面向切面编程（AOP）：Spring 的 AOP 功能可以与 Bean 一起使用，使你能够在应用程序中轻松实现横切关注点，例如日志记录、事务管理等。 Bean的定义 在Spring中，可以通过配置元数据来定义Bean，包括Bean的类型、属性值和依赖关系等。 有三种重要的方法给 Spring 容器提供配置元数据：\n基于 XML 的配置 基于 注解 的配置 基于 java类 的配置 Bean的作用域 Spring框架支持以下五种Bean的作用域：\nsingleton : Bean 在每个 Spring ioc 容器中只有一个实例。 prototype：一个 Bean 的定义可以有多个实例。 request：每次 http 请求都会创建一个 Bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。 session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。 global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。该作用域仅在基于 web 的Spring ApplicationContext 情形下有效。 tip 缺省的 Spring Bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 Bean 会带来很大的性能开销。\nBean的生命周期 Spring 容器管理 Bean 的整个生命周期，包括以下关键步骤：\n实例化（Instantiation）：\n根据 Bean 的定义，Spring 容器实例化 Bean 对象，并将其存储在容器中。Spring 框架会取出 BeanDefinition 的信息进行判断当前 Bean 的范围是否是 singleton 的，是否不是延迟加载的，是否不是 FactoryBean 等，最终将一个普通的 singleton 的 Bean 通过反射进行实例化； 属性注入（Dependency Injection）：\nSpring 容器检测 Bean 的依赖关系并将所需的依赖注入到 Bean 中，例如通过构造函数注入或 Setter 方法注入。 初始化（Initialization）：\nBean 创建之后还仅仅是个\u0026quot;半成品\u0026quot;，还需要对 Bean 实例的属性进行填充、执行一些 Aware 接口方法、执行 BeanPostProcessor 方法、执行 InitializingBean 接口的初始化方法、执行自定义初始化init方法等。如果 Bean 实现了 InitializingBean 接口或在配置中指定了初始化方法，Spring 容器将调用 Bean 的初始化方法。 使用（In Use）：\n经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池 singletonObjects 中去了，Bean 可以在应用程序的其他组件中使用，执行它们的业务逻辑。 销毁（Destruction）：\n如果 Bean 实现了 DisposableBean 接口或在配置中指定了销毁方法，Spring 容器在销毁时调用 Bean 的销毁方法。 Bean的实例化过程 读取 BeanDefinition 到 BeanDefinitionMap 执行 BeanDefinitionRegistryPostProcessor 执行 BeanDefinitionPostProcessor 创建 Bean 实例 Bean的初始化过程 Bean 实例的属性填充 Aware 接口属性注入 BeanPostProcessor 的 before() 方法回调 InitializingBean 接口的初始化方法回调 自定义初始化方法 init 回调 BeanPostProcessor 的 after() 方法回调 Bean的三级缓存 Spring 提供了三级缓存存储完整 Bean 实例 和 半成品 Bean 实例，用于解决循环引用问题。\n在 DefaultListableBeanFactory 的上四级父类 DefaultSingletonBeanRegistry 中提供如下三个Map：\nBean的线程安全问题 在 Spring 框架中，默认情况下，单例 Bean 是线程安全的。Spring 容器在创建单例 Bean 时会确保只有一个实例，并在需要时共享该实例。这意味着多个线程可以同时访问同一个单例 Bean 实例，而无需担心并发问题。\nSpring 实现单例 Bean 的线程安全性有以下几个方面：\n无状态Bean：Spring 鼓励在单例 Bean 中避免使用实例变量（或将其保持在只读状态），从而避免了多个线程之间共享状态的风险。如果单例 Bean 是无状态的，那么多个线程之间并发访问不会引发竞态条件。\n依赖注入： Spring 通过依赖注入的方式来管理 Bean 之间的依赖关系。当多个线程同时访问一个单例 Bean 时，它们将共享相同的依赖项实例。由于依赖项是单独的 Bean 实例，并且默认也是单例的，因此它们可以安全地被多个线程共享。\n线程封闭性： Spring 单例 Bean 默认是无状态的，但如果需要在单例 Bean 中使用可变状态，则可以使用线程封闭性来确保线程安全。线程封闭性是指将可变状态限制在每个线程的范围内，每个线程独立拥有自己的状态实例。通过使用线程封闭性，可以确保每个线程独立访问自己的状态，从而避免并发问题。\n多线程下，Spring如何确保有状态的Bean的线程安全 在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题。\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n","pubDate":"2022-05-22","title":"Bean概念"},{"link":"https://cuctut.github.io/posts/beanfactory%E5%92%8Capplicationcontext/","plain":"BeanFactory BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实 例。通常只提供注册（put），获取（get）这两个功能，可以称之为 “低级容器”。\nBeanFactory简单用法\nApplicationContext ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。\nApplicationContext简单用法\n两者的关系 原笔记\n继承 在 IDEA 内查看 ApplicationContext 的继承体系，如下：\nApplicationContext 接口继承自 BeanFactory\n先后 BeanFactory 是 Spring 的早期接口，称为 Spring 的 Bean 工厂； ApplicationContext 是后期更高级接口,称之为 Spring 容器； 扩展 Bean 创建的主要逻辑和功能都被封装在 BeanFactory 中，ApplicationContext 继承了 BeanFactory，内部还维护着 BeanFactory 的引用，ApplicationContext 在 BeanFactory 基础上对功能进行了扩展，如：监听功能、国际化功能等。BeanFactory 的 API 更偏向底层，ApplicationContext 的 API 大多数是对这些底层 API 的封装;\n继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 所以, ApplicationContext 与 BeanFactory 既有继承关系，又有融合关系。\n两者的区别 Bean 的初始化时机 BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调用 getBean 方法才会抛出异常。 ApplicationContext 是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例Bean，通过预载入单实例 bean，确保当你需要的时候，就不用等待，因为它们已经创建好了。 创建方式 BeanFactory 通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。\n注册方式 两者都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：\nBeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。\n其他 ApplicationContext 常用实现 FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，需要正确设置classpath因为这个容器将在classpath里找bean配置。 WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有 bean。 ","pubDate":"2022-05-21","title":"BeanFactory和ApplicationContext"},{"link":"https://cuctut.github.io/posts/spring%E6%A6%82%E5%BF%B5%E7%AF%87/","plain":"为什么使用Spring框架？ 轻量：解决企业级应用开发的复杂性，即简化Java开发 IOC：通过IOC容器对Bean的生命周期进行管理，让开发者只需关心业务的需求，同时实现对象依赖松耦合的管理 AOP：通过切面的方式对功能进行增强，减少代码的侵入性 MVC：Spring提供SpringMVC框架对Web开发进行支持 事务管理：声明式事务的支持，只需要通过配置就可以完成对事务的管理，可以通过AOP实现对事务的统一管理 生态支持：拥有强大的生态和社区 Spring模块 Spring模块有大约 20 个，它们提供的特性组成了Spring框架。\n这些模块分：Core Container, Data Access/Integration, Web, AOP, Instrumentation, Messaging 和 Test，如下图所示。\nSpring的两大核心概念 IOC（Inversion of Control，控制反转）和AOP（Aspect-Oriented Programming，面向切面编程）是两种开发中的重要概念。\nIOC (Inversion of Control，控制反转) IOC是一种设计原则，它将控制权的获取和管理从应用程序代码转移到一个外部容器或框架。在传统的编程模型中，应用程序代码通常会直接创建和管理对象的依赖关系。而在IOC模式下，应用程序通过定义对象之间的依赖关系，并且将对象的创建和生命周期交给外部容器来管理。外部容器负责创建、装配和管理对象，并且在需要时将对象注入到应用程序中。这样可以实现对象之间的解耦和灵活性。\nIOC 的实现机制 Spring 中的 IOC 的实现原理就是工厂模式加反射机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 interface Fruit { public abstract void eat(); } class Apple implements Fruit { public void eat(){ System.out.println(\u0026#34;Apple\u0026#34;); } } class Orange implements Fruit { public void eat(){ System.out.println(\u0026#34;Orange\u0026#34;); } } class Factory { public static Fruit getInstance(String ClassName) { Fruit f=null; try { f=(Fruit)Class.forName(ClassName).newInstance(); } catch (Exception e) { e.printStackTrace(); } return f; } } class Client { public static void main(String[] a) { Fruit f=Factory.getInstance(\u0026#34;Apple\u0026#34;); if(f!=null){ f.eat(); } } } AOP (Aspect-Oriented Programming，面向切面编程) AOP是一种编程范式，它通过将横切关注点（cross-cutting concerns）从主要业务逻辑中分离出来，实现模块化的开发和维护。横切关注点是那些存在于应用程序各个部分的功能需求，如日志记录、事务管理、安全性等，它们通常跨越多个对象和模块。AOP通过定义切面（aspect）来封装横切关注点，并将其与主要业务逻辑进行解耦。切面可以在应用程序运行时动态地织入到主要业务逻辑中，从而实现对横切关注点的统一管理和复用。\nSpring 中的设计模式 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例； 单例模式：Bean默认为单例模式； 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术； 模板方法：用来解决代码重复的问题。比如.RestTemplate, JmsTemplate, JpaTemplate； 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。 ","pubDate":"2022-05-21","title":"Spring概念篇"},{"link":"https://cuctut.github.io/posts/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","plain":"前言 关于本主题的使用文档，参考了 LoveIt 和 MemE 主题。在阅读过程中如果有不太明白的地方，一定要用好你的浏览器，如果你是懒或是忘了的话，在这可提醒你一次了。话不多说，操作起来。\n安装 不同的操作系统，安装方式可能有所不同，以下的操作都是在 macOS 上完成的。对于其他操作系统，请查看 Hugo 的安装。\n安装 Hugo NewBee 主题由 Hugo 引擎驱动，Hugo 是一个快速而现代的静态网站生成器，由 Go 语言编写。\n对于 Mac 系统，Hugo 官方使用的是 Homebrew 或 MacPorts 来安装，如果你电脑里没有，请先下载一个。详情请移步：Hugo在macOS上的安装\n::: tabs\n@tab Homebrew\n1 ~ % brew install hugo @tab MacPorts\n1 ~ % port install hugo :::\n安装后验证一下是否安装成功，命令行输入：\n1 ~ % hugo version 如果输出结果类似这样：\n1 ~ % hugo v0.91.2+extended darwin/amd64 BuildDate=unknown 则安装成功。\n安装 NewBee 创建一个新项目，首先，创建一个目录作为你的博客根目录，示例目录文件名为: my-blog。Hugo 提供了通过new site命令来快速创建网站的方法：\n1 ~ % hugo new site my-blog 得到以下文件（文件的位置取决于你执行命令时所在的目录）：\nNewBee 主题的仓库是：https://github.com/xioyito/NewBee，有以下 2 种方法来安装 NewBee 主题：\n::: tabs\n@tab 方法1\n下载主题最新版本的 .zip 文件，解压后放到themes目录。\n@tab 方法2\n把主题克隆到themes目录：\n1 2 ~ % cd my-blog my-blog % git clone https://github.com/xioyito/NewBee.git themes/NewBee :::\n开始 Hugo 和 NewBee 都安装完毕后，就可以开始我们博客的 “Hello World” 了。\n替换 config.toml 进入themes/NewBee/config-example目录，复制config.toml文件，替换掉my-blog/config.toml文件。\n新建文章 1 my-blog % hugo new \u0026#34;posts/first-post.md\u0026#34; 你可能需要一个关于页面，所以：\n1 my-blog % hugo new \u0026#34;about/_index.md\u0026#34; 文章内容使用 Markdown 编辑，关于 Markdown 基本语法，请参考：Markdown 教程\n启动本地服务器 1 my-blog % hugo server -D 浏览器打开：http://localhost:1313/，这就是我们网站的首页了，你可以快速预览网站效果。\ntip 1. 当你运行hugo server -D时, 如果文件内容更改, 页面会随着更改自动刷新。\n2. hugo server -D和hugo server的差别：后者不会渲染前置参数draft: true的文章，这意味着在预览网站时你不会看到这篇文章的任何信息。\n语法高亮样式 hugo 查找文件的方式是这样的：先查找网站根目录my-blog下有没有该文件，如果没有，再查找my-blog/themes/Newbee下的。所以，理论上根目录下的任何文件都能覆盖掉主题文件下的对应文件。自定义时，建议在根目录下进行，而不是直接对主题文件进行修改，以免出错。\nHugo的语法高亮基于 chroma，并提供了足够的样式风格供你选择。如果NewBee主题默认的高亮样式不适合你，你可以参照如下方式修改：\n先进行以下操作：\n1 ~ % hugo gen chromastyles --style=你喜欢的样式名称 \u0026gt; syntax.css 这样可以得到一个syntax.css文件，文件的位置取决于你执行上述命令时所在的目录，然后将其复制到my-blog/static/css文件夹下即可。一般情况下不用再对其进行修改，当然也不是不可以，这完全取决于你的心情。\n如果你还想把深色模式下的语法高亮样式也更改了，操作同上面一样，只要在命令行操作时把syntax.css换成syntax-dark.css即可。\ntip 如果语法高亮有显示问题，对syntax.css进行修改就行，深色模式则修改syntax-dark.css。\n部署 一切准备就绪后，是时候把我们的网站放到网络上了。你可以使用 Netlify、Render、Firebase、Github 以及更多。下面简要介绍部署到Github的过程，更多方式请移步 部署和托管。\n准备 在 Github 上的部署，我们需要用到 Github Page，它是 GitHub 提供的一个网页寄存服务，可以寄存静态页面，非常适合博客的搭建。首先在自己的 Github 账号里创建一个 Repository（仓库），命名为你的Github账号名.github.io，例如我的仓库名xioyito.github.io。\n生成静态页面文件 1 my-blog % hugo 这个命令会在根目录下生成一个public目录, 其中包含你网站的所有静态内容和资源.\nwarning 在生成静态页面之前要把config.toml文件中的baseURL修改为自己博客的网址：https://你的Github账号名.github.io。\n部署到Github 进入public文件夹，使用 git 上传文件。\n1 2 3 4 5 6 my-blog % cd public public % git init # 初始化仓库 public % git remote add origin https://github.com/你的Github账号名/你的Github账号名.github.io.git # 链接远程仓库 public % git add . public % git commit -m \u0026#34;first commit\u0026#34; public % git push -u origin master 以后更新文章的时候，同样是用 hugo 生成新的页面文件，git 上传文件。\n1 2 3 4 5 my-blog % hugo my-blog % cd public public % git add . public % git commit -m \u0026#34;first commit\u0026#34; public % git push tip 上传文件到 Github 时，可能会出现和 git 的使用相关的问题，请自行百度解决。\n等一会儿，就可以打开我们的网站了：https://你的Github账号名.github.io。\ntip 等待的时长和你的网络状况有很大关系。\n避坑指南 一定要看这篇文章：避坑指南\n","pubDate":"2022-04-21","title":"本博客的部署"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

