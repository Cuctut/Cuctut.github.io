<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Cuctut&#39;s blog | 博客部署</title>
    <meta name="description" content=" ">
    <link rel="canonical" href="https://cuctut.github.io/series/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="博客部署" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cuctut.github.io/series/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="博客部署"/>
<meta name="twitter:description" content=""/>

    
        
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    
    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
        <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">Cuctut&#39;s blog</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/portfolio">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-spin fa-star'></i> 作品集</div>
                        </div>
                    </div>
                </a>
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/portfolio">
            <div class="burger-item">
                <i class='fa fa-spin fa-star'></i> 作品集
            </div>
        </a>
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
    




    <div class="hero">
        
            
                <div class="hero-img">
                    <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/default/default3.jpg" alt="">
                </div>
            
        <div class="hero-content">
            <h1 class="hero-title">系列: 博客部署</h1>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="terms-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="terms-row">
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/default/default3.jpg" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cuctut.github.io/posts/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">本博客的部署</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2022-4-21 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2023-3-28 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/web
                                    '>
                                web
                            </a>
                
            </span>
        </div>
        <div class="down-summary"></div>
    </div>
    <div class="card-readmore">
        <a href="https://cuctut.github.io/posts/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>




<div class="dang"></div>
            </div>
            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">Cuctut</div>
            <div class="jianjie">
                Be the change.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>9</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>4</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>3</p>
        </a>
    </div>

    <a href="https://github.com/Cuctut">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/Cuctut" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://space.bilibili.com/172938182" class="link-item is-hidden-desktop" title="BiliBili">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://cuctut.github.io/posts/sql%E8%AF%AD%E6%B3%95/">
                
<a href="https://cuctut.github.io/posts/sql%E8%AF%AD%E6%B3%95/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://images.unsplash.com/photo-1543722615-dbf5edf1a00d?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1476&amp;q=80 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                SQL语法
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-5-25</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">
                
<a href="https://cuctut.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://images.unsplash.com/photo-1543722615-dbf5edf1a00d?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1476&amp;q=80 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                数据库基础
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-5-25</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%843%E7%A7%8D%E5%8E%9F%E5%9B%A0/">
                
<a href="https://cuctut.github.io/posts/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%843%E7%A7%8D%E5%8E%9F%E5%9B%A0/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://images.unsplash.com/photo-1543722615-dbf5edf1a00d?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1476&amp;q=80 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                MySQL自增主键不连续的3种原因
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2023-5-23</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/spring%E4%BA%8B%E5%8A%A1/">
                
<a href="https://cuctut.github.io/posts/spring%E4%BA%8B%E5%8A%A1/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://images.pexels.com/photos/5632396/pexels-photo-5632396.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1%22 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Spring事务
            </div>
            <div class="other-summary">什么是事务？ 事务是逻辑上的一组操作，要么都执行，要么都不执行。 我们系统的每个业务方法可能包括了多个原</div>
            <div class="other-date">2023-5-23</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cuctut.github.io/posts/aop%E6%A6%82%E5%BF%B5/">
                
<a href="https://cuctut.github.io/posts/aop%E6%A6%82%E5%BF%B5/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://pic3.zhimg.com/v2-d7f3d00e1ae3d13a950ca9b81d2c3f22_r.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                AOP概念
            </div>
            <div class="other-summary"></div>
            <div class="other-date">2022-5-22</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/Cuctut">Cuctut</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
        
    <div>
        <meting-js
            server = "netease"
            type = "playlist"
            id = "482655706"
            fixed = "true"
            autoplay = "false"
            loop = "all"
            order = "list"
            preload = "auto"
            list-folded = ""
            list-max-height = "250px"
            lrc-type = "1">
        </meting-js>
    </div>

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  9 ;
    var arrPosts = [{"link":"https://cuctut.github.io/posts/sql%E8%AF%AD%E6%B3%95/","plain":"前言 只对不常使用的和比较深的概念做摘录，方便温习，具体例子详见出处链接。\nSQL语法基础知识总结 链接 -\u0026gt; SQL语法基础知识总结\n-\u0026gt; MySQL 索引详解\n-\u0026gt; 后端程序员必备：SQL 高性能优化指南！35+条优化建议立马 GET!\n-\u0026gt; 后端程序员必备：书写高质量 SQL 的 30 条建议\n-\u0026gt; SQL常见面试题总结\n数据定义 视图（VIEW） 定义：\n视图是基于 SQL 语句的结果集的可视化的表。 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 作用：\n简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 创建视图 1 2 3 4 CREATE VIEW top_10_user_view AS SELECT id, username FROM user WHERE id \u0026lt; 10; 删除视图 1 DROP VIEW top_10_user_view; 索引（INDEX） 索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。\n优点：\n使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点：\n创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 但是，使用索引一定能提高查询性能吗?\n大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。\n关于索引的详细介绍，请看:\n-\u0026gt; MySQL 索引详解\n创建索引 1 2 CREATE INDEX user_index ON user (id); 添加索引 1 ALTER table user ADD INDEX user_index(id) 创建唯一索引 1 2 CREATE UNIQUE INDEX user_index ON user (id); 删除索引 1 2 ALTER TABLE user DROP INDEX user_index; 约束 SQL 约束用于规定表中的数据规则。\n如果存在违反约束的数据行为，行为会被约束终止。\n约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。\n约束类型：\nNOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 创建表时使用约束条件：\n1 2 3 4 5 6 7 8 CREATE TABLE Users ( Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \u0026#39;自增Id\u0026#39;, Username VARCHAR(64) NOT NULL UNIQUE DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;用户名\u0026#39;, Password VARCHAR(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;密码\u0026#39;, Email VARCHAR(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;邮箱地址\u0026#39;, Enabled TINYINT(4) DEFAULT NULL COMMENT \u0026#39;是否有效\u0026#39;, PRIMARY KEY (Id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\u0026#39;用户表\u0026#39;; 事务处理 Transaction control lauguage，事务控制语言， TCL 。TCL 的主要功能是管理数据库中的事务。\n不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。\n通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。\n指令：\nSTART TRANSACTION - 指令用于标记事务的起始点。 SAVEPOINT - 指令用于创建保留点。 ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。 COMMIT - 提交事务。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 开始事务 START TRANSACTION; -- 插入操作 A INSERT INTO `user` VALUES (1, \u0026#39;root1\u0026#39;, \u0026#39;root1\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); -- 创建保留点 updateA SAVEPOINT updateA; -- 插入操作 B INSERT INTO `user` VALUES (2, \u0026#39;root2\u0026#39;, \u0026#39;root2\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); -- 回滚到保留点 updateA ROLLBACK TO updateA; -- 提交事务，只有操作 A 生效 COMMIT; 权限控制 要授予用户帐户权限，可以用GRANT命令。有撤销用户的权限，可以用REVOKE命令。这里以 MySQl 为例，介绍权限控制实际应用。\nGRANT授予权限语法：\n1 2 3 4 GRANT privilege,[privilege],.. ON privilege_level TO user [IDENTIFIED BY password] [REQUIRE tsl_option] [WITH [GRANT_OPTION | resource_option]]; 简单解释一下：\n在GRANT关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。 ON privilege_level 确定权限应用级别。MySQL 支持 global（*.*），database（database.*），table（database.table）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。 user 是要授予权限的用户。如果用户已存在，则GRANT语句将修改其权限。否则，GRANT语句将创建一个新用户。可选子句IDENTIFIED BY允许您为用户设置新的密码。 REQUIRE tsl_option指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。 可选 WITH GRANT OPTION 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用WITH子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。 REVOKE 撤销权限语法：\n1 2 3 4 REVOKE privilege_type [(column_list)] [, priv_type [(column_list)]]... ON [object_type] privilege_level FROM user [, user]... 简单解释一下：\n在 REVOKE 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。 指定在 ON 子句中撤销特权的特权级别。 指定要撤消 FROM 子句中的权限的用户帐户。 GRANT 和 REVOKE 可在几个层次上控制访问权限：\n整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 新创建的账户没有任何权限。账户用 username@host 的形式定义，username@% 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。\n1 2 USE mysql; SELECT user FROM user; 下表说明了可用于GRANT和REVOKE语句的所有允许权限：\n特权 说明 级别 全局 数据库 表 列 程序 代理 ALL [PRIVILEGES] 授予除 GRANT OPTION 之外的指定访问级别的所有权限 ALTER 允许用户使用 ALTER TABLE 语句 X X X ALTER ROUTINE 允许用户更改或删除存储的例程 X X X CREATE 允许用户创建数据库和表 X X X CREATE ROUTINE 允许用户创建存储的例程 X X CREATE TABLESPACE 允许用户创建，更改或删除表空间和日志文件组 X CREATE TEMPORARY TABLES 允许用户使用 CREATE TEMPORARY TABLE 创建临时表 X X CREATE USER 允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。 X CREATE VIEW 允许用户创建或修改视图。 X X X DELETE 允许用户使用 DELETE X X X DROP 允许用户删除数据库，表和视图 X X X EVENT 启用事件计划程序的事件使用。 X X EXECUTE 允许用户执行存储的例程 X X X FILE 允许用户读取数据库目录中的任何文件。 X GRANT OPTION 允许用户拥有授予或撤消其他帐户权限的权限。 X X X X X INDEX 允许用户创建或删除索引。 X X X INSERT 允许用户使用 INSERT 语句 X X X X LOCK TABLES 允许用户对具有 SELECT 权限的表使用 LOCK TABLES X X PROCESS 允许用户使用 SHOW PROCESSLIST 语句查看所有进程。 X PROXY 启用用户代理。 REFERENCES 允许用户创建外键 X X X X RELOAD 允许用户使用 FLUSH 操作 X REPLICATION CLIENT 允许用户查询以查看主服务器或从属服务器的位置 X REPLICATION SLAVE 允许用户使用复制从属从主服务器读取二进制日志事件。 X SELECT 允许用户使用 SELECT 语句 X X X X SHOW DATABASES 允许用户显示所有数据库 X SHOW VIEW 允许用户使用 SHOW CREATE VIEW 语句 X X X SHUTDOWN 允许用户使用 mysqladmin shutdown 命令 X SUPER 允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令 X TRIGGER 允许用户使用 TRIGGER 操作。 X X X UPDATE 允许用户使用 UPDATE 语句 X X X X USAGE 相当于“没有特权” 创建账户 1 CREATE USER myuser IDENTIFIED BY \u0026#39;mypassword\u0026#39;; 修改账户名 1 2 UPDATE user SET user=\u0026#39;newuser\u0026#39; WHERE user=\u0026#39;myuser\u0026#39;; FLUSH PRIVILEGES; 删除账户 1 DROP USER myuser; 查看权限 1 SHOW GRANTS FOR myuser; 授予权限 1 GRANT SELECT, INSERT ON *.* TO myuser; 删除权限 1 REVOKE SELECT, INSERT ON *.* FROM myuser; 更改密码 1 SET PASSWORD FOR myuser = \u0026#39;mypass\u0026#39;; SQL语法应用 比较重要的：理解分组（GROUP）、连接（JOIN）以及他们附带的USING、ON、HAVING等等用法！\n-\u0026gt; SQL常见面试题总结\n","pubDate":"2023-05-25","title":"SQL语法"},{"link":"https://cuctut.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","plain":"数据库基础知识总结 链接 包括数据库、数据库管理系统、数据库系统、数据库管理员、元组、各种码、范式的概念。\n-\u0026gt; 数据库基础\n为什么不推荐使用外键与级联？ 对于外键和级联，阿里巴巴开发手册这样说到：\n【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度\n为什么不要用外键呢？大部分人可能会这样回答：\n增加了复杂性： a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。 增加了额外工作：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。） 对分库分表不友好：因为分库分表下外键是无法生效的。 \u0026hellip;\u0026hellip; 我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：\n保证了数据库数据的一致性和完整性； 级联操作方便，减轻了程序代码量； \u0026hellip;\u0026hellip; 所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理。\n如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。\n什么是存储过程? 我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。\n存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n阿里巴巴 Java 开发手册里要求禁止使用存储过程。\ndrop、delete 与 truncate 区别？ 用法不同 drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。 truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。 truncate 和不带 where子句的 delete、以及 drop 都会删除表内的数据，但是 truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行drop 之后对应的表不复存在。\n属于不同的数据库语言 truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。\nDML 语句和 DDL 语句区别：\nDML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。 DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。 另外，由于select不会对表进行破坏，所以有的地方也会把select单独区分开叫做数据库查询语言 DQL（Data Query Language）。\n执行速度不同 一般来说：drop \u0026gt; truncate \u0026gt; delete（这个我没有设计测试过）。\ndelete命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。 truncate命令执行的时候不会产生数据库日志，因此比delete要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。 drop命令会把表占用的空间全部释放掉。 Tips：你应该更多地关注在使用场景上，而不是执行效率。\nNoSQL基础知识总结 NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n-\u0026gt;NoSQL基础\n字符集详解 -\u0026gt;字符集详解\n","pubDate":"2023-05-25","title":"数据库基础"},{"link":"https://cuctut.github.io/posts/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%843%E7%A7%8D%E5%8E%9F%E5%9B%A0/","plain":"前言 自增主键的特点是当表中每新增一条记录时，主键值会根据自增步长自动叠加，通常会将自增步长设置1，也就是说自增主键值是连续的。那么MySQL自增主键值一定会连续吗？今天这篇文章就来说说这个问题，看看什么情况下自增主键会出现不连续?\n实验 数据准备 1 2 3 4 5 6 7 8 9 drop TABLE increnment_test; -- 创建包含白增主键的表 CREATE TABLE increnment_test ( id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, col1 INT(11) NOT NULL, col2 INT(11) NOT NULL, col3 INT(11) NOT NULL, UNIQUE KEY (col1) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; 唯一键冲突 比如increnment_test表中已经存在了col1为 3 的记录，我们继续插入col1为 3 的记录，此时会出现唯一键冲突插入报错，但是没有将自增值再改回去。重新插入col1为 4 的值，此时对应的id为 5;\n1 2 3 4 select * from increnmont_test; INSERT INTO increnment test (coll, col2, col3) VALUES (3, 3, 3); INSERT INTO increnment_test (col1, co12, col3) VALUES (4, 4, 4); 结果：理想下应该id为4，现实是5\nid col1 col2 col3 1 1 1 1 2 2 2 2 3 3 3 3 5 4 4 4 原因：InnoDB引擎的自增值修改流程\n执行器调用InnoDB引擎接口将分析器优化后的SQL传入,并将值(3,3,3)一起传过去 InnoDB发现用户没有指定自增id列,会先获取表increnment_test当前的自增值3 将ID列补充完整,并且将自增值填入(3,3,3,3) 然后将表的自增值改成4 继续执行插入数据操作; 唯一键冲突，插入失败，但自增值还是4，不回退 继续插入(4,4,4)，重复上面流程，使用4+1=5作为自增值 tip 自增字段值的生成是由存储引擎自动完成的,而不是由优化器完成的。因此,在执行SQL语句时,即使未指定自增字段列,也不会对性能产生任何影响。\n事务回滚 开启一个事务插入col1为 6 的数据，然后进行回滚。回滚后重新插入col1为 6 的记录，此时col1为 6 的id值为 7\n1 2 3 4 5 6 7 BEGIN; INSERT INTO increnment_test (col1, col2, col3) VALUES(6, 6, 6); ROLLBACK; BEGIN; INSERT INTO increnment_test (col1, col2, col3) VALUES(6, 6, 6); COMMIT; 结果：理想下应该id为6，现实是7\nid col1 col2 col3 1 1 1 1 2 2 2 2 3 3 3 3 5 4 4 4 7 6 6 6 原因和唯一键冲突一致，都是自增值没有回退导致。\n批量插入数据 创建一个和increnment_test相同结构的表increnment_test2，将前者的内容全部插入到后者，再插入一条数据，如下：\n1 2 3 4 5 6 7 drop table increnment_test2; create table increnment_test2 like increnment_test; INSERT INTO increnment_test2 (col1, col2, col3) SELECT col1, col2, col3 FROM increnment_test; INSERT INTO increnment_test2 (col1, col2, col3) VALUES (8, 8, 8); SELECT * FROM increnment_test2; 结果：理想下应该id为6，现实是8\n（前面1~5的id是新表increnment_test2自增分配的，不复制increnment_test的）\nid col1 col2 col3 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 6 6 6 8 8 8 8 原因：\n对于批量插入数据的语句，如：insert … select、replace … select 和 load data 语句，这时不确定要插入多少条数据，所以无法一次性准确地申请对应个数的id，此时 MySQL 有一个批量申请自增 id 的策略：\nSQL语句执行过程中,第1次申请自增id,会分配1个; 1个用完以后，第2次申请自增id，会分配2个； 2个用完以后，第3次申请自增 id，会分配4个； 依此类推，同一个语句去申请自增 id，每次申请到的自增id个数都是上一次的两倍。\n对于此例，第一次分配的是1，第二次分配的是2、3，第三次是4、5、6、7，在插入(8, 8, 8)前，自增id只用到5，而6、7已经分配出去，继续插入单条，自增后直接分配到8，所以会从8开始（不会分配8~15，因为不是批量插入）\ntip 通过insert into table(col1,col2) values(a,b),(b,c)\u0026hellip;这种一次插入多条数据时除外，因为这种方式插入多条数据时，申请id的个数是可以准确计算的。\n扩展 摘自https://www.modb.pro/db/131854，里面的扩展部分关于自增值的修改策略虽不重要，但也很受益。\n自增值的保存位置 我们可以通过 show create table table_name 命令查看某个表当前的 AUTO_IINCREMENT 值，那么是不是这个自增值和表结构定义保存在一起？其实并不是，表结构定义保存在后缀为.frm的文件中，而自增值并不在。\nMyISAM 引擎的自增值保存在数据文件中。\nInnoDB 引擎的自增值，在 MySQL 5.7 及之前的版本是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是：\n在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。\n在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。\n为什么不在插入数据失败时将自增值改回去？ 假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。\n事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。 事务 B 正确提交了，但事务 A 出现了唯一键冲突。 如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。 接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。 而为了解决这个主键冲突，有两种方法：\n每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。 把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。 可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增 id 回退”的前提导致的。\n因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。\n自增锁 MySQL里面有一种锁叫自增锁，是在申请自增主键值的时候填加的锁，但这种锁并不是事务锁，在 MySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。\n显然，这样设计会影响并发度。MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。(8.x版本这个参数的默认值已经改为了2)\n这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁； 这个参数的值被设置为 1 时：普通 insert 语句，自增锁在申请之后就马上释放；类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放； 这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。 为什么5.1.22引入innodb_autoinc_lock_mode参数时默认值为1，而8.0将默认值设改成了2 来自ChatGPT：\n在MySQL数据库中，innodb_autoinc_lock_mode参数用于控制InnoDB存储引擎中自增列（auto-increment column）的锁定方式。\n在版本5.1.22中引入innodb_autoinc_lock_mode参数时，其默认值被设置为1。这意味着在插入新行时，InnoDB将使用传统的表级锁（table-level lock）来锁定整个表，以确保自增列的唯一性。这种锁定方式可以有效地保证自增列的唯一性，但在并发插入时可能会导致性能瓶颈，因为每次插入操作都需要锁定整个表。\n然而，在MySQL 8.0版本中，innodb_autoinc_lock_mode参数的默认值被改为2。这意味着InnoDB现在使用更为灵活的行级锁（row-level lock）来锁定自增列。使用行级锁可以更好地支持并发插入操作，因为不同的插入操作可以同时进行，而不需要等待对整个表的锁定。\n通过将innodb_autoinc_lock_mode参数的默认值从1更改为2，MySQL 8.0提供了更好的并发性能，尤其在高并发的写入负载下。但需要注意的是，这可能会导致一些特殊情况下的自增列值不连续（例如，回滚的事务可能导致自增值未被使用），因此在特定应用场景中可能需要进行适当的调整。\n总结而言，MySQL 8.0将innodb_autoinc_lock_mode参数的默认值改为2是为了提高并发插入的性能，但也需要根据具体情况进行评估和调整。\n","pubDate":"2023-05-23","title":"MySQL自增主键不连续的3种原因"},{"link":"https://cuctut.github.io/posts/spring%E4%BA%8B%E5%8A%A1/","plain":"什么是事务？ 事务是逻辑上的一组操作，要么都执行，要么都不执行。\n我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 savePerson() 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。\n1 2 3 4 public void savePerson() { personDao.save(person); personDetailDao.save(personDetail); } 事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 innodb引擎。但是，如果把数据库引擎变为 myisam，那么程序也就不再支持事务了！\n事务的特性（ACID） 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 tip 这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！\nMySQL 怎么保证原子性的？ 我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。\nSpring中的事务管理 Spring事务的本质是数据库对事务的支持。没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。\n两种开发方式实现事务管理 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。 大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。\n编程式事务管理 通过 TransactionTemplate 或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于理解 Spring 事务管理原理有帮助。\n使用 TransactionTemplate 进行编程式事务管理的示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Autowired private TransactionTemplate transactionTemplate; public void testTransaction() { transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { try { // .... 业务代码 } catch (Exception e){ //回滚 transactionStatus.setRollbackOnly(); } } }); } 使用 TransactionManager 进行编程式事务管理的示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private PlatformTransactionManager transactionManager; public void testTransaction() { TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { // .... 业务代码 transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } } 声明式事务管理 推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional的全注解方式使用最多）。\n使用 @Transactional 注解进行事务管理的示例代码如下：\n1 2 3 4 5 6 7 8 @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something B b = new B(); C c = new C(); b.bMethod(); c.cMethod(); } Spring 事务管理接口介绍 Spring 框架中，事务管理相关最重要的 3 个接口如下：\nPlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心，是事务上层的管理者。 TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)，是事务的描述。 TransactionStatus：事务运行状态，是事务的描述。 PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。\nPlatformTransactionManager Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是：PlatformTransactionManager 。\n通过这个接口，Spring 为各个平台如：\nJDBC (DataSourceTransactionManager)\nHibernate(HibernateTransactionManager)\nJPA (JpaTransactionManager)\n等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。\nPlatformTransactionManager 接口的具体实现如下: PlatformTransactionManager 接口中定义了三个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 package org.springframework.transaction; import org.springframework.lang.Nullable; public interface PlatformTransactionManager { //获得事务 TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException; //提交事务 void commit(TransactionStatus var1) throws TransactionException; //回滚事务 void rollback(TransactionStatus var1) throws TransactionException; } TransactionDefinition 事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition 类 ，这个类就定义了一些基本的事务属性。\n事务属性包含了 5 个方面：\n隔离级别 传播行为 回滚规则 是否只读 事务超时 TransactionDefinition 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.springframework.transaction; import org.springframework.lang.Nullable; public interface TransactionDefinition { int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; int ISOLATION_DEFAULT = -1; int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; int TIMEOUT_DEFAULT = -1; // 返回事务的传播行为，默认值为 REQUIRED。 int getPropagationBehavior(); //返回事务的隔离级别，默认值是 DEFAULT int getIsolationLevel(); // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。 int getTimeout(); // 返回是否为只读事务，默认值为 false boolean isReadOnly(); @Nullable String getName(); } TransactionStatus TransactionStatus 接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息.PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。\nTransactionStatus 接口内容如下：\n1 2 3 4 5 6 7 public interface TransactionStatus{ boolean isNewTransaction(); // 是否是新的事务 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成 } 事务属性详解 事务属性是在 TransactionDefinition 中定义的，比较重要的是事务传播行为和事务隔离级别\n事务传播行为 事务传播行为：当多个事务同时存在的时候，spring如何处理这些事务的行为，解决的是业务层方法之间互相调用的事务问题。\ntip 举个例子：我们在 A 类的 aMethod()方法中调用了 B 类的 bMethod() 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 bMethod()如果发生异常需要回滚，如何配置事务传播行为才能让 aMethod()也跟着回滚呢？这个时候就需要事务传播行为的知识了。\n在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：\n1 2 3 4 5 6 7 8 9 10 public interface TransactionDefinition { int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; ...... } 为了方便使用，Spring 相应地定义了一个枚举类：Propagation\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package org.springframework.transaction.annotation; import org.springframework.transaction.TransactionDefinition; public enum Propagation { REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED), SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS), MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY), REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW), NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED), NEVER(TransactionDefinition.PROPAGATION_NEVER), NESTED(TransactionDefinition.PROPAGATION_NESTED); private final int value; Propagation(int value) { this.value = value; } public int value() { return this.value; } } 1. REQUIRED 使用的最多的一个事务传播行为，我们平时经常使用的 @Transactional 注解默认使用就是这个事务传播行为。\n如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\n也就是说：如果外部方法没有开启事务的话，Propagation.REQUIRED 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。如果外部方法开启事务并且被 Propagation.REQUIRED 的话，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。举个例子：如果我们上面的 aMethod() 和 bMethod() 使用的都是 PROPAGATION_REQUIRED 传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service Class A { @Autowired B b; @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something b.bMethod(); } } @Service Class B { @Transactional(propagation = Propagation.REQUIRED) public void bMethod { //do something } } 2. REQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。\n举个例子：如果我们上面的 bMethod() 使用 PROPAGATION_REQUIRES_NEW 事务传播行为修饰， aMethod 还是用 PROPAGATION_REQUIRED 修饰的话。如果 aMethod() 发生异常回滚， bMethod() 不会跟着回滚，因为 bMethod() 开启了独立的事务。但是，如果 bMethod() 抛出了未被捕获的异常并且这个异常满足事务回滚规则的话, aMethod() 同样也会回滚，因为这个异常被 aMethod() 的事务管理机制检测到了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service Class A { @Autowired B b; @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something b.bMethod(); } } @Service Class B { @Transactional(propagation = Propagation.REQUIRED_NEW) public void bMethod { //do something } } 3. NESTED 如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与 REQUIRED 类似的操作。也就是说：在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。如果外部方法无事务，则单独开启一个事务，与 REQUIRED 类似。\n这里还是简单举个例子：如果 bMethod() 回滚的话，aMethod()不会回滚。如果 aMethod() 回滚的话，bMethod()会回滚。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service Class A { @Autowired B b; @Transactional(propagation = Propagation.REQUIRED) public void aMethod { //do something b.bMethod(); } } @Service Class B { @Transactional(propagation = Propagation.NESTED) public void bMethod { //do something } } 4. MANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n这个使用的很少，就不举例子来说了。\n5. 其他 若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。 SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。\n更多关于事务传播行为的内容请看这篇文章：\n《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》\n事务隔离级别 TransactionDefinition 接口中定义了五个表示隔离级别的常量：\n1 2 3 4 5 6 7 8 9 public interface TransactionDefinition { ...... int ISOLATION_DEFAULT = -1; int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; ...... } 为了方便使用，Spring 也相应地定义了一个枚举类： Isolation\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public enum Isolation { DEFAULT(TransactionDefinition.ISOLATION_DEFAULT), READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED), READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED), REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ), SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); private final int value; Isolation(int value) { this.value = value; } public int value() { return this.value; } } DEFAULT : 使用后端数据库默认的隔离级别，MySQL 默认采用 REPEATABLE_READ 隔离级别，Oracle 默认采用READ_COMMITTED 隔离级别 READ_UNCOMMITTED : 最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 相关阅读：MySQL 事务隔离级别详解\n事务超时属性 所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为-1，这表示事务的超时时间取决于底层事务系统或者没有超时时间。\n事务只读属性 1 2 3 4 5 6 7 8 9 10 package org.springframework.transaction; import org.springframework.lang.Nullable; public interface TransactionDefinition { ...... // 返回是否为只读事务，默认值为 false boolean isReadOnly(); } 对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。\n为什么一个数据查询操作还要启用事务支持呢？\n拿 MySQL 的 innodb 举例子\ntip MySQL 默认对每一个新建立的连接都启用了 autocommit 模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。\n但是，如果你给方法加上了 Transactional 注解的话，这个方法执行的所有sql会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。如果不加 Transactional ，每条sql会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。\n关于事务只读属性，其他人的解答：\n如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性； 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持# 事务回滚规则 事务回滚规则 这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（RuntimeException 的子类，可自定义异常类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。 如果你想要回滚你定义的特定的异常类型的话，可以这样：\n1 @Transactional(rollbackFor= MyException.class) @Transactional 注解 @Transactional 的作用范围 方法：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。 类：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。 接口：不推荐在接口上使用。 @Transactional 的常用配置参数 @Transactional 注解源码如下，里面包含了基本事务属性的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Transactional { @AliasFor(\u0026#34;transactionManager\u0026#34;) String value() default \u0026#34;\u0026#34;; @AliasFor(\u0026#34;value\u0026#34;) String transactionManager() default \u0026#34;\u0026#34;; Propagation propagation() default Propagation.REQUIRED; Isolation isolation() default Isolation.DEFAULT; int timeout() default TransactionDefinition.TIMEOUT_DEFAULT; boolean readOnly() default false; Class\u0026lt;? extends Throwable\u0026gt;[] rollbackFor() default {}; String[] rollbackForClassName() default {}; Class\u0026lt;? extends Throwable\u0026gt;[] noRollbackFor() default {}; String[] noRollbackForClassName() default {}; } 属性名 说明 propagation 事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过 isolation 事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过 timeout 事务的超时时间，默认为-1（不会超时）。超时但事务没完成，则自动回滚。 readOnly 指定事务是否为只读事务，默认值为 false。 rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。 @Transactional 事务注解原理 @Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。\n如果一个类或者一个类中的 public 方法上被标注 @Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被 @Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke() 方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。\nSpring AOP 自调用问题 若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效。\ntip 这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。\nMyService 类中的method1()调用method2()就会导致method2()的事务失效。\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class MyService { private void method1() { method2(); //...... } @Transactional public void method2() { //...... } } 解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。\n@Transactional 的使用注意事项总结 @Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用； 避免同一个类中调用 @Transactional 注解的方法，这样会导致事务失效； 正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败; 被 @Transactional 注解的方法所在的类必须被 Spring 管理，否则不生效； 底层使用的数据库必须支持事务机制，否则不生效； 参考资料 Spring 事务详解\n参考\n","pubDate":"2023-05-23","title":"Spring事务"},{"link":"https://cuctut.github.io/posts/aop%E6%A6%82%E5%BF%B5/","plain":"AOP A OP，即一个OP，指一个原批（误）\n什么是AOP AOP，Aspect Oriented Programming，面向切面编程，是面向对象编程 OOP 的升华。\nOOP 是纵向对某事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。\nAOP 是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程。\nAOP中的相关概念 概念 单词 解释 目标对象 Target 被增强的方法所在的对象 代理对象 Proxy 对目标对象进行增强后的对象，客户端实际调用的对象 连接点 Joinpoint 目标对象中可以被增强的方法 切入点 Pointcut 目标对象中实际被增强的方法 通知/增强 Advice 增强部分的代码逻辑 切面 Aspect 增强和切入点的组合 织入 Weaving 将通知和切入点组合动态组合的过程 具体解释 切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n通知（Advice）：在AOP术语中，切面的工作被称为通知。\n切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。\n引入（Introduction）：引入允许我们向现有类添加新方法或属性。\n目标对象（Target Object）：被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced）对象。既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied）对象。\n织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：\n编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面 Spring AOP 通知类型 在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过 Spring AOP 框架触发的代码段。\nSpring切面可以应用5种类型的通知：\n前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning ）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 AOP 代理模式 一个OP自身精力有限，想继续肝下去需要请OP小代帮忙肝圣遗物（真）\nAOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。\nSpring AOP 和 AspectJ AOP 区别 AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为编译时增强，他会在编译阶段将 AspectJ (切面)织入到 Java 字节码中，运行的时候就是增强之后的 AOP 对象。\nSpring AOP 使用的动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。\n静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。\nwarning 因为 Spring 基于动态代理，所以 Spring 只支持方法连接点。Spring 缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用 Aspect 来补充。\nJDK 动态代理 和 CGLIB 动态代理的区别 Spring AOP 中的动态代理主要有两种方式，JDK 动态代理 和 CGLIB 动态代理：\nJDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler 动态创建一个符合某一接口的的实例, 生成目标类的代理对象。如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。\nCGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。\n其他 应用 tip Notion 笔记，一些网络代理节点可能无法访问，如在clash中要切换到DIRECT模式\n基于 xml 配置 AOP\n基于注解配置AOP\n关注点和横切关注的区别 关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 参考资料 83-Spring的AOP开发-模拟AOP思想实现方案_哔哩哔哩_bilibili\n","pubDate":"2022-05-22","title":"AOP概念"},{"link":"https://cuctut.github.io/posts/bean%E6%A6%82%E5%BF%B5/","plain":"什么是 Spring Bean？ Spring Bean 是指在Spring容器中被管理的对象。可以是任何的Java对象，如实体类、服务类、数据访问对象(DAO)等。它们被 Spring IOC 容器初始化，装配，和管理。这些 Bean 根据容器中配置的元数据创建。比如，以 XML 文件中的形式定义。\ntip 传统 Java Bean 由开发人员手动创建和管理生命周期，手动处理依赖关系，配置通常在代码中直接进行，维护性差。由于没有 AOP 概念，若要实现诸如事务管理、日志记录等横切功能，传统 Java Bean 通常需要开发人员手动编写和管理横切逻辑。而 Spring Bean 的特点解决了这些问题。\nBean的特点 Spring Bean具有以下特点：\n生命周期管理：Spring 容器负责Bean的生命周期，它负责在需要时创建Bean实例、初始化 Bean、将依赖注入到 Bean 中以及在不再需要时销毁 Bean 实例。 依赖注入：Spring 容器通过依赖注入机制自动解决 Bean 之间的依赖关系。这意味着你可以使用注解或配置将其他 Bean 注入到你的 Bean 中，从而实现解耦和灵活性。 配置灵活性：Spring 容器允许通过配置文件或注解来定义 Bean 及其属性。这使得你可以轻松修改 Bean 的配置，而无需修改源代码。 面向切面编程（AOP）：Spring 的 AOP 功能可以与 Bean 一起使用，使你能够在应用程序中轻松实现横切关注点，例如日志记录、事务管理等。 Bean的定义 在Spring中，可以通过配置元数据来定义Bean，包括Bean的类型、属性值和依赖关系等。 有三种重要的方法给 Spring 容器提供配置元数据：\n基于 XML 的配置 基于 注解 的配置 基于 java类 的配置 Bean的作用域 Spring框架支持以下五种Bean的作用域：\nsingleton : Bean 在每个 Spring ioc 容器中只有一个实例。 prototype：一个 Bean 的定义可以有多个实例。 request：每次 http 请求都会创建一个 Bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。 session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。 global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。该作用域仅在基于 web 的Spring ApplicationContext 情形下有效。 tip 缺省的 Spring Bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 Bean 会带来很大的性能开销。\nBean的生命周期 Spring 容器管理 Bean 的整个生命周期，包括以下关键步骤：\n实例化（Instantiation）：\n根据 Bean 的定义，Spring 容器实例化 Bean 对象，并将其存储在容器中。Spring 框架会取出 BeanDefinition 的信息进行判断当前 Bean 的范围是否是 singleton 的，是否不是延迟加载的，是否不是 FactoryBean 等，最终将一个普通的 singleton 的 Bean 通过反射进行实例化； 属性注入（Dependency Injection）：\nSpring 容器检测 Bean 的依赖关系并将所需的依赖注入到 Bean 中，例如通过构造函数注入或 Setter 方法注入。 初始化（Initialization）：\nBean 创建之后还仅仅是个\u0026quot;半成品\u0026quot;，还需要对 Bean 实例的属性进行填充、执行一些 Aware 接口方法、执行 BeanPostProcessor 方法、执行 InitializingBean 接口的初始化方法、执行自定义初始化init方法等。如果 Bean 实现了 InitializingBean 接口或在配置中指定了初始化方法，Spring 容器将调用 Bean 的初始化方法。 使用（In Use）：\n经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池 singletonObjects 中去了，Bean 可以在应用程序的其他组件中使用，执行它们的业务逻辑。 销毁（Destruction）：\n如果 Bean 实现了 DisposableBean 接口或在配置中指定了销毁方法，Spring 容器在销毁时调用 Bean 的销毁方法。 Bean的实例化过程 读取 BeanDefinition 到 BeanDefinitionMap 执行 BeanDefinitionRegistryPostProcessor 执行 BeanDefinitionPostProcessor 创建 Bean 实例 Bean的初始化过程 Bean 实例的属性填充 Aware 接口属性注入 BeanPostProcessor 的 before() 方法回调 InitializingBean 接口的初始化方法回调 自定义初始化方法 init 回调 BeanPostProcessor 的 after() 方法回调 Bean的三级缓存 Spring 提供了三级缓存存储完整 Bean 实例 和 半成品 Bean 实例，用于解决循环引用问题。\n在 DefaultListableBeanFactory 的上四级父类 DefaultSingletonBeanRegistry 中提供如下三个Map：\nBean的线程安全问题 在 Spring 框架中，默认情况下，单例 Bean 是线程安全的。Spring 容器在创建单例 Bean 时会确保只有一个实例，并在需要时共享该实例。这意味着多个线程可以同时访问同一个单例 Bean 实例，而无需担心并发问题。\nSpring 实现单例 Bean 的线程安全性有以下几个方面：\n无状态Bean：Spring 鼓励在单例 Bean 中避免使用实例变量（或将其保持在只读状态），从而避免了多个线程之间共享状态的风险。如果单例 Bean 是无状态的，那么多个线程之间并发访问不会引发竞态条件。\n依赖注入： Spring 通过依赖注入的方式来管理 Bean 之间的依赖关系。当多个线程同时访问一个单例 Bean 时，它们将共享相同的依赖项实例。由于依赖项是单独的 Bean 实例，并且默认也是单例的，因此它们可以安全地被多个线程共享。\n线程封闭性： Spring 单例 Bean 默认是无状态的，但如果需要在单例 Bean 中使用可变状态，则可以使用线程封闭性来确保线程安全。线程封闭性是指将可变状态限制在每个线程的范围内，每个线程独立拥有自己的状态实例。通过使用线程封闭性，可以确保每个线程独立访问自己的状态，从而避免并发问题。\n多线程下，Spring如何确保有状态的Bean的线程安全 在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题。\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n","pubDate":"2022-05-22","title":"Bean概念"},{"link":"https://cuctut.github.io/posts/beanfactory%E5%92%8Capplicationcontext/","plain":"BeanFactory BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实 例。通常只提供注册（put），获取（get）这两个功能，可以称之为 “低级容器”。\nBeanFactory简单用法\nApplicationContext ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。\nApplicationContext简单用法\n两者的关系 原笔记\n继承 在 IDEA 内查看 ApplicationContext 的继承体系，如下：\nApplicationContext 接口继承自 BeanFactory\n先后 BeanFactory 是 Spring 的早期接口，称为 Spring 的 Bean 工厂； ApplicationContext 是后期更高级接口,称之为 Spring 容器； 扩展 Bean 创建的主要逻辑和功能都被封装在 BeanFactory 中，ApplicationContext 继承了 BeanFactory，内部还维护着 BeanFactory 的引用，ApplicationContext 在 BeanFactory 基础上对功能进行了扩展，如：监听功能、国际化功能等。BeanFactory 的 API 更偏向底层，ApplicationContext 的 API 大多数是对这些底层 API 的封装;\n继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 所以, ApplicationContext 与 BeanFactory 既有继承关系，又有融合关系。\n两者的区别 Bean 的初始化时机 BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调用 getBean 方法才会抛出异常。 ApplicationContext 是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例Bean，通过预载入单实例 bean，确保当你需要的时候，就不用等待，因为它们已经创建好了。 创建方式 BeanFactory 通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。\n注册方式 两者都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：\nBeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。\n其他 ApplicationContext 常用实现 FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，需要正确设置classpath因为这个容器将在classpath里找bean配置。 WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有 bean。 ","pubDate":"2022-05-21","title":"BeanFactory和ApplicationContext"},{"link":"https://cuctut.github.io/posts/spring%E6%A6%82%E5%BF%B5%E7%AF%87/","plain":"为什么使用Spring框架？ 轻量：解决企业级应用开发的复杂性，即简化Java开发 IOC：通过IOC容器对Bean的生命周期进行管理，让开发者只需关心业务的需求，同时实现对象依赖松耦合的管理 AOP：通过切面的方式对功能进行增强，减少代码的侵入性 MVC：Spring提供SpringMVC框架对Web开发进行支持 事务管理：声明式事务的支持，只需要通过配置就可以完成对事务的管理，可以通过AOP实现对事务的统一管理 生态支持：拥有强大的生态和社区 Spring模块 Spring模块有大约 20 个，它们提供的特性组成了Spring框架。\n这些模块分：Core Container, Data Access/Integration, Web, AOP, Instrumentation, Messaging 和 Test，如下图所示。\nSpring的两大核心概念 IOC（Inversion of Control，控制反转）和AOP（Aspect-Oriented Programming，面向切面编程）是两种开发中的重要概念。\nIOC (Inversion of Control，控制反转) IOC是一种设计原则，它将控制权的获取和管理从应用程序代码转移到一个外部容器或框架。在传统的编程模型中，应用程序代码通常会直接创建和管理对象的依赖关系。而在IOC模式下，应用程序通过定义对象之间的依赖关系，并且将对象的创建和生命周期交给外部容器来管理。外部容器负责创建、装配和管理对象，并且在需要时将对象注入到应用程序中。这样可以实现对象之间的解耦和灵活性。\nIOC 的实现机制 Spring 中的 IOC 的实现原理就是工厂模式加反射机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 interface Fruit { public abstract void eat(); } class Apple implements Fruit { public void eat(){ System.out.println(\u0026#34;Apple\u0026#34;); } } class Orange implements Fruit { public void eat(){ System.out.println(\u0026#34;Orange\u0026#34;); } } class Factory { public static Fruit getInstance(String ClassName) { Fruit f=null; try { f=(Fruit)Class.forName(ClassName).newInstance(); } catch (Exception e) { e.printStackTrace(); } return f; } } class Client { public static void main(String[] a) { Fruit f=Factory.getInstance(\u0026#34;Apple\u0026#34;); if(f!=null){ f.eat(); } } } AOP (Aspect-Oriented Programming，面向切面编程) AOP是一种编程范式，它通过将横切关注点（cross-cutting concerns）从主要业务逻辑中分离出来，实现模块化的开发和维护。横切关注点是那些存在于应用程序各个部分的功能需求，如日志记录、事务管理、安全性等，它们通常跨越多个对象和模块。AOP通过定义切面（aspect）来封装横切关注点，并将其与主要业务逻辑进行解耦。切面可以在应用程序运行时动态地织入到主要业务逻辑中，从而实现对横切关注点的统一管理和复用。\nSpring 中的设计模式 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例； 单例模式：Bean默认为单例模式； 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术； 模板方法：用来解决代码重复的问题。比如.RestTemplate, JmsTemplate, JpaTemplate； 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。 ","pubDate":"2022-05-21","title":"Spring概念篇"},{"link":"https://cuctut.github.io/posts/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","plain":"前言 关于本主题的使用文档，参考了 LoveIt 和 MemE 主题。在阅读过程中如果有不太明白的地方，一定要用好你的浏览器，如果你是懒或是忘了的话，在这可提醒你一次了。话不多说，操作起来。\n安装 不同的操作系统，安装方式可能有所不同，以下的操作都是在 macOS 上完成的。对于其他操作系统，请查看 Hugo 的安装。\n安装 Hugo NewBee 主题由 Hugo 引擎驱动，Hugo 是一个快速而现代的静态网站生成器，由 Go 语言编写。\n对于 Mac 系统，Hugo 官方使用的是 Homebrew 或 MacPorts 来安装，如果你电脑里没有，请先下载一个。详情请移步：Hugo在macOS上的安装\n::: tabs\n@tab Homebrew\n1 ~ % brew install hugo @tab MacPorts\n1 ~ % port install hugo :::\n安装后验证一下是否安装成功，命令行输入：\n1 ~ % hugo version 如果输出结果类似这样：\n1 ~ % hugo v0.91.2+extended darwin/amd64 BuildDate=unknown 则安装成功。\n安装 NewBee 创建一个新项目，首先，创建一个目录作为你的博客根目录，示例目录文件名为: my-blog。Hugo 提供了通过new site命令来快速创建网站的方法：\n1 ~ % hugo new site my-blog 得到以下文件（文件的位置取决于你执行命令时所在的目录）：\nNewBee 主题的仓库是：https://github.com/xioyito/NewBee，有以下 2 种方法来安装 NewBee 主题：\n::: tabs\n@tab 方法1\n下载主题最新版本的 .zip 文件，解压后放到themes目录。\n@tab 方法2\n把主题克隆到themes目录：\n1 2 ~ % cd my-blog my-blog % git clone https://github.com/xioyito/NewBee.git themes/NewBee :::\n开始 Hugo 和 NewBee 都安装完毕后，就可以开始我们博客的 “Hello World” 了。\n替换 config.toml 进入themes/NewBee/config-example目录，复制config.toml文件，替换掉my-blog/config.toml文件。\n新建文章 1 my-blog % hugo new \u0026#34;posts/first-post.md\u0026#34; 你可能需要一个关于页面，所以：\n1 my-blog % hugo new \u0026#34;about/_index.md\u0026#34; 文章内容使用 Markdown 编辑，关于 Markdown 基本语法，请参考：Markdown 教程\n启动本地服务器 1 my-blog % hugo server -D 浏览器打开：http://localhost:1313/，这就是我们网站的首页了，你可以快速预览网站效果。\ntip 1. 当你运行hugo server -D时, 如果文件内容更改, 页面会随着更改自动刷新。\n2. hugo server -D和hugo server的差别：后者不会渲染前置参数draft: true的文章，这意味着在预览网站时你不会看到这篇文章的任何信息。\n语法高亮样式 hugo 查找文件的方式是这样的：先查找网站根目录my-blog下有没有该文件，如果没有，再查找my-blog/themes/Newbee下的。所以，理论上根目录下的任何文件都能覆盖掉主题文件下的对应文件。自定义时，建议在根目录下进行，而不是直接对主题文件进行修改，以免出错。\nHugo的语法高亮基于 chroma，并提供了足够的样式风格供你选择。如果NewBee主题默认的高亮样式不适合你，你可以参照如下方式修改：\n先进行以下操作：\n1 ~ % hugo gen chromastyles --style=你喜欢的样式名称 \u0026gt; syntax.css 这样可以得到一个syntax.css文件，文件的位置取决于你执行上述命令时所在的目录，然后将其复制到my-blog/static/css文件夹下即可。一般情况下不用再对其进行修改，当然也不是不可以，这完全取决于你的心情。\n如果你还想把深色模式下的语法高亮样式也更改了，操作同上面一样，只要在命令行操作时把syntax.css换成syntax-dark.css即可。\ntip 如果语法高亮有显示问题，对syntax.css进行修改就行，深色模式则修改syntax-dark.css。\n部署 一切准备就绪后，是时候把我们的网站放到网络上了。你可以使用 Netlify、Render、Firebase、Github 以及更多。下面简要介绍部署到Github的过程，更多方式请移步 部署和托管。\n准备 在 Github 上的部署，我们需要用到 Github Page，它是 GitHub 提供的一个网页寄存服务，可以寄存静态页面，非常适合博客的搭建。首先在自己的 Github 账号里创建一个 Repository（仓库），命名为你的Github账号名.github.io，例如我的仓库名xioyito.github.io。\n生成静态页面文件 1 my-blog % hugo 这个命令会在根目录下生成一个public目录, 其中包含你网站的所有静态内容和资源.\nwarning 在生成静态页面之前要把config.toml文件中的baseURL修改为自己博客的网址：https://你的Github账号名.github.io。\n部署到Github 进入public文件夹，使用 git 上传文件。\n1 2 3 4 5 6 my-blog % cd public public % git init # 初始化仓库 public % git remote add origin https://github.com/你的Github账号名/你的Github账号名.github.io.git # 链接远程仓库 public % git add . public % git commit -m \u0026#34;first commit\u0026#34; public % git push -u origin master 以后更新文章的时候，同样是用 hugo 生成新的页面文件，git 上传文件。\n1 2 3 4 5 my-blog % hugo my-blog % cd public public % git add . public % git commit -m \u0026#34;first commit\u0026#34; public % git push tip 上传文件到 Github 时，可能会出现和 git 的使用相关的问题，请自行百度解决。\n等一会儿，就可以打开我们的网站了：https://你的Github账号名.github.io。\ntip 等待的时长和你的网络状况有很大关系。\n避坑指南 一定要看这篇文章：避坑指南\n","pubDate":"2022-04-21","title":"本博客的部署"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

